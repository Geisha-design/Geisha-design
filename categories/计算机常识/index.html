<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content="java leetcode mysql hexo"/>



    <meta name="description" content="雨争齐齐齐"/>


<meta name="Robots" content="all">


    <title>齐雨争</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="../../css/font-awesome.min.css">


<link rel="stylesheet" href="../../css/atom-one-dark.css">


<link rel="stylesheet" href="../../css/style.css">


<script src="../../js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/24/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E2%80%9D/">“计算机文件系统”</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-24</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/24/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E2%80%9D/">
                    <p>
                        
                            

前言不多 BB，直接上「硬菜」。


正文文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。
文件系统的基本数据单位是文件，它的目的是对磁盘上的文件进行组织管理，那组织的方式不同，就会形成不同的文件系统。
Linux 最经典的一句话是：「一切皆文件」，不仅普通的文件和目录，就连块设备、管道、socket 等，也都是统一交给文件系统管理的。
Linux 文件系统会为每个文件分配两个数据结构：索引节点（*index node*）和目录项（*directory entry*），它们主要用来记录文件的元信息和目录层次结构。

索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。
目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。

由于索引节点唯一标识一个文件，而目录项记录着文件的名，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别字。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。
注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。

目录项和目录是一个东西吗？

虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。
如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。
注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。

那文件数据是如何存储在磁盘的呢？

磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。
所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。
以上就是索引节点、目录项以及文件数据的关系，下面这个图就很好的展示了它们之间的关系：

索引节点是存储在硬盘上的数据，那么为了加速文件的访问，通常会把索引节点加载到内存中。
另外，磁盘进行格式化的时候，会被分成三个存储区域，分别是超级块、索引节点区和数据块区。 - 超级块，用来存储文件系统的详细信息，比如块个数、块大小、空闲块等等。 - 索引节点区，用来存储索引节点； - 数据块区，用来存储文件或目录数据；
我们不可能把超级块和索引节点区全部加载到内存，这样内存肯定撑不住，所以只有当需要使用的时候，才将其加载进内存，它们加载进内存的时机是不同的：

超级块：当文件系统挂载时进入内存；
索引节点区：当文件被访问时进入内存；


虚拟文件系统文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（*Virtual File System，VFS*）。
VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。
在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：

Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：

磁盘的文件系统，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。
内存的文件系统，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 /proc 和 /sys 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。
网络的文件系统，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。

文件的使用我们从用户角度来看文件的话，就是我们要怎么使用文件？首先，我们得通过系统调用来打开一个文件。

12345fd = open(name, flag); # 打开文件...write(fd,...);         # 写数据...close(fd);             # 关闭文件

上面简单的代码是读取一个文件的过程： - 首先用 open 系统调用打开文件，open 的参数中包含文件的路径名和文件名。 - 使用 write 写数据，其中 write 使用 open 所返回的文件描述符，并不使用文件名作为参数。 - 使用完文件后，要用 close 系统调用关闭文件，避免资源的泄露。
我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「文件描述符」，所以说文件描述符是打开文件的标识。

操作系统在打开文件表中维护着打开文件的状态和信息： - 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； - 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； - 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； - 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；
在用户视角里，文件就是一个持久化的数据结构，但操作系统并不会关心你想存在磁盘上的任何的数据结构，操作系统的视角是如何把文件数据和磁盘块对应起来。
所以，用户和操作系统对文件的读写操作是有差异的，用户习惯以字节的方式读写文件，而操作系统则是以数据块来读写文件，那屏蔽掉这种差异的工作就是文件系统了。
我们来分别看一下，读文件和写文件的过程：

当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。
当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。

所以说，文件系统的基本操作单位是数据块。

文件的存储文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：

连续空间存放方式
非连续空间存放方式

其中，非连续空间存放方式又可以分为「链表方式」和「索引方式」。
不同的存储方式，有各自的特点，重点是要分析它们的存储效率和读写性能，接下来分别对每种存储方式说一下。
连续空间存放方式连续空间存放方式顾名思义，文件存放在磁盘「连续的」物理空间中。这种模式下，文件的数据都是紧密相连，读写效率很高，因为一次磁盘寻道就可以读出整个文件。
使用连续存放的方式有一个前提，必须先知道一个文件的大小，这样文件系统才会根据文件的大小在磁盘上找到一块连续的空间分配给文件。
所以，文件头里需要指定「起始块的位置」和「长度」，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间。
注意，此处说的文件头，就类似于 Linux 的 inode。

连续空间存放的方式虽然读写效率高，但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷。
如下图，如果文件 B 被删除，磁盘上就留下一块空缺，这时，如果新来的文件小于其中的一个空缺，我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺，但却小于空缺大小之和，则虽然磁盘上有足够的空缺，但该文件还是不能存放。当然了，我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件，但是这个在磁盘挪动文件是非常耗时，所以这种方式不太现实。

另外一个缺陷是文件长度扩展不方便，例如上图中的文件 A 要想扩大一下，需要更多的磁盘空间，唯一的办法就只能是挪动的方式，前面也说了，这种方式效率是非常低的。
那么有没有更好的方式来解决上面的问题呢？答案当然有，既然连续空间存放的方式不太行，那么我们就改变存放的方式，使用非连续空间存放方式来解决这些缺陷。
非连续空间存放方式非连续空间存放方式分为「链表方式」和「索引方式」。

我们先来看看链表的方式。

链表的方式存放是离散的，不用连续的，于是就可以消除磁盘碎片，可大大提高磁盘空间的利用率，同时文件的长度可以动态扩展。根据实现的方式的不同，链表可分为「隐式链表」和「显式链接」两种形式。
文件要以「隐式链表」的方式存放的话，实现的方式是文件头要包含「第一块」和「最后一块」的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块的位置，这样一个数据块连着一个数据块，从链头开是就可以顺着指针找到所有的数据块，所以存放的方式可以是不连续的。

隐式链表的存放方式的缺点在于无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间。隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。
如果取出每个磁盘块的指针，把它放在内存的一个表中，就可以解决上述隐式链表的两个不足。那么，这种实现方式是「显式链接」，它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，该表在整个磁盘仅设置一张，每个表项中存放链接指针，指向下一个数据块号。
对于显式链接的工作方式，我们举个例子，文件 A 依次使用了磁盘块 4、7、2、10 和 12 ，文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表，可以从第 4 块开始，顺着链走到最后，找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找出文件 B 的全部磁盘块。最后，这两个链都以一个不属于有效磁盘编号的特殊标记（如 -1 ）结束。内存中的这样一个表格称为文件分配表（*File Allocation Table，FAT*）。

由于查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。但也正是整个表都存放在内存中的关系，它的主要的缺点是不适用于大磁盘。
比如，对于 200GB 的磁盘和 1KB 大小的块，这张表需要有 2 亿项，每一项对应于这 2 亿个磁盘块中的一个块，每项如果需要 4 个字节，那这张表要占用 800MB 内存，很显然 FAT 方案对于大磁盘而言不太合适。

接下来，我们来看看索引的方式。

链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题，但是不能有效支持直接访问（FAT除外），索引的方式可以解决这个问题。
索引的实现是为每个文件创建一个「索引数据块」，里面存放的是指向文件数据块的指针列表，说白了就像书的目录一样，要找哪个章节的内容，看目录查就可以。
另外，文件头需要包含指向「索引数据块」的指针，这样就可以通过文件头知道索引数据块的位置，再通过索引数据块里的索引信息找到对应的数据块。
创建文件时，索引块的所有指针都设为空。当首次写入第 i 块时，先从空闲空间中取得一个块，再将其地址写到索引块的第 i 个条目。

索引的方式优点在于： - 文件的创建、增大、缩小很方便； - 不会有碎片的问题； - 支持顺序读写和随机读写；
由于索引数据也是存放在磁盘块的，如果文件很小，明明只需一块就可以存放的下，但还是需要额外分配一块来存放索引数据，所以缺陷之一就是存储索引带来的开销。
如果文件很大，大到一个索引数据块放不下索引信息，这时又要如何处理大文件的存放呢？我们可以通过组合的方式，来处理大文件的存。
先来看看链表 + 索引的组合，这种组合称为「链式索引块」，它的实现方式是在索引数据块留出一个存放下一个索引数据块的指针，于是当一个索引数据块的索引信息用完了，就可以通过指针的方式，找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题，万一某个指针损坏了，后面的数据也就会无法读取了。

还有另外一种组合方式是索引 + 索引的方式，这种组合称为「多级索引块」，实现方式是通过一个索引块来存放多个索引数据块，一层套一层索引，像极了俄罗斯套娃是吧。

Unix 文件的实现方式我们先把前面提到的文件实现方式，做个比较：

那早期 Unix 文件系统是组合了前面的文件存放方式的优点，如下图：

它是根据文件的大小，存放的方式会有所变化：

如果存放文件所需的数据块小于 10 块，则采用直接查找的方式；
如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式；
如果前面两种方式都不够存放大文件，则采用二级间接索引方式；
如果二级间接索引也不够存放大文件，这采用三级间接索引方式；

那么，文件头（Inode）就需要包含 13 个指针： - 10 个指向数据块的指针； - 第 11 个指向索引块的指针； - 第 12 个指向二级索引块的指针； - 第 13 个指向三级索引块的指针；
所以，这种方式能很灵活地支持小文件和大文件的存放： - 对于小文件使用直接查找的方式可减少索引数据块的开销； - 对于大文件则以多级索引的方式来支持，所以大文件在访问数据块时需要大量查询；
这个方案就用在了 Linux Ext 2/3 文件系统里，虽然解决大文件的存储，但是对于大文件的访问，需要大量的查询，效率比较低。
为了解决这个问题，Ext 4 做了一定的改变，具体怎么解决的，本文就不展开了。

空闲空间管理前面说到的文件的存储是针对已经被占用的数据块组织和管理，接下来的问题是，如果我要保存一个数据块，我应该放在硬盘上的哪个位置呢？难道需要将所有的块扫描一遍，找个空的地方随便放吗？
那这种方式效率就太低了，所以针对磁盘的空闲空间也是要引入管理的机制，接下来介绍几种常见的方法：

空闲表法
空闲链表法
位图法

空闲表法空闲表法就是为所有空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数，注意，这个方式是连续分配的。如下图：

当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止。当用户撤销一个文件时，系统回收文件空间。这时，也需顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。
这种方法仅当有少量的空闲区时才有较好的效果。因为，如果存储空间中有着大量的小的空闲区，则空闲表变得很大，这样查询效率会很低。另外，这种分配技术适用于建立连续文件。
空闲链表法我们也可以使用「链表」的方式来管理空闲空间，每一个空闲块里有一个指针指向下一个空闲块，这样也能很方便的找到空闲块并管理起来。如下图：

当创建文件需要一块或几块时，就从链头上依次取下一块或几块。反之，当回收空间时，把这些空闲块依次接到链头上。
这种技术只要在主存中保存一个指针，令它指向第一个空闲块。其特点是简单，但不能随机访问，工作效率低，因为每当在链上增加或移动空闲块时需要做很多 I/O 操作，同时数据块的指针消耗了一定的存储空间。
空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。
位图法位图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。
当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：
11111110011111110001110110111111100111 ...

在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。

文件系统的结构前面提到 Linux 是用位图的方式管理空闲空间，用户在创建一个新文件时，Linux 内核会通过 inode 的位图找到空闲可用的 inode，并进行分配。要存储数据时，会通过块的位图找到空闲的块，并分配，但仔细计算一下还是有问题的。
数据块的位图是放在磁盘块里的，假设是放在一个块里，一个块 4K，每位表示一个数据块，共可以表示 4 * 1024 * 8 = 2^15 个空闲块，由于 1 个数据块是 4K 大小，那么最大可以表示的空间为 2^15 * 4 * 1024 = 2^27 个 byte，也就是 128M。
也就是说按照上面的结构，如果采用「一个块的位图 + 一系列的块」，外加「一个块的 inode 的位图 + 一系列的 inode 的结构」能表示的最大空间也就 128M，这太少了，现在很多文件都比这个大。
在 Linux 文件系统，把这个结构称为一个块组，那么有 N 多的块组，就能够表示 N 大的文件。
下图给出了 Linux Ext2 整个文件系统的结构和块组的内容，文件系统都由大量块组组成，在硬盘上相继排布：

最前面的第一个块是引导块，在系统启动时用于启用引导，接着后面就是一个一个连续的块组了，块组的内容如下： - 超级块，包含的是文件系统的重要信息，比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。 - 块组描述符，包含文件系统中各个块组的状态，比如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中「所有块组的组描述符信息」。 - 数据位图和 inode 位图， 用于表示对应的数据块或 inode 是空闲的，还是被使用中。 - inode 列表，包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据。 - 数据块，包含文件的有用数据。
你可以会发现每个块组里有很多重复的信息，比如超级块和块组描述符表，这两个都是全局信息，而且非常的重要，这么做是有两个原因： - 如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的。 - 通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能。
不过，Ext2 的后续版本采用了稀疏技术。该做法是，超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。

目录的存储在前面，我们知道了一个普通文件是如何存储的，但还有一个特殊的文件，经常用到的目录，它是如何保存的呢？
基于 Linux 一切皆文件的设计思想，目录其实也是个文件，你甚至可以通过 vim 打开它，它也有 inode，inode 里面也是指向一些块。
和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。
在目录文件的块中，最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。
列表中每一项就代表该目录下的文件的文件名和对应的 inode，通过这个 inode，就可以找到真正的文件。

通常，第一项是「.」，表示当前目录，第二项是「..」，表示上一级目录，接下来就是一项一项的文件名和 inode。
如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。
于是，保存目录的格式改成哈希表，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。
Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。
目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I/O 操作，开销较大。所以，为了减少 I/O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。

软链接和硬链接有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（*Hard Link*） 和软链接（*Symbolic Link*） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。
硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。

软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。


文件 I/O文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有

缓冲与非缓冲 I/O
直接与非直接 I/O
阻塞与非阻塞 I/O VS 同步与异步 I/O

接下来，分别对这些分类讨论讨论。
缓冲与非缓冲 I/O文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O： - 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。 - 非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。
这里所说的「缓冲」特指标准库内部实现的缓冲。
比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。
直接与非直接 I/O我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。
那么，根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：

直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。
非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。

如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。

如果用了非直接 I/O 进行写数据操作，内核什么情况下才会把缓存数据写入到磁盘？

以下几种场景会触发内核缓存的数据写入磁盘： - 在调用 write 的最后，当发现内核缓存的数据太多的时候，内核会把数据写到磁盘上； - 用户主动调用 sync，内核缓存会刷到磁盘上； - 当内存十分紧张，无法再分配页面时，也会把内核缓存的数据刷到磁盘上； - 内核缓存的数据的缓存时间超过某个时间时，也会把数据刷到磁盘上；
阻塞与非阻塞 I/O VS 同步与异步 I/O为什么把阻塞 / 非阻塞与同步与异步放一起说的呢？因为它们确实非常相似，也非常容易混淆，不过它们之间的关系还是有点微妙的。
先来看看阻塞 I/O，当用户程序执行 read ，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，当拷贝过程完成，read 才会返回。
注意，阻塞等待的是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程。过程如下图：

知道了阻塞 I/O ，来看看非阻塞 I/O，非阻塞的 read 请求在数据未准备好的情况下立即返回，可以继续往下执行，此时应用程序不断轮询内核，直到数据准备好，内核将数据拷贝到应用程序缓冲区，read 调用才可以获取到结果。过程如下图：

注意，这里最后一次 read 调用，获取数据的过程，是一个同步的过程，是需要等待的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。
举个例子，访问管道或 socket 时，如果设置了 O_NONBLOCK 标志，那么就表示使用的是非阻塞 I/O 的方式访问，而不做任何设置的话，默认是阻塞 I/O。
应用程序每次轮询内核的 I/O 是否准备好，感觉有点傻乎乎，因为轮询的过程中，应用程序啥也做不了，只是在循环。
为了解决这种傻乎乎轮询方式，于是 I/O 多路复用技术就出来了，如 select、poll，它是通过 I/O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。
这个做法大大改善了应用进程对 CPU 的利用率，在没有被通知的情况下，应用进程可以使用 CPU 做其他的事情。
下图是使用 select I/O 多路复用过程。注意，read 获取数据的过程（数据从内核态拷贝到用户态的过程），也是一个同步的过程，需要等待：

实际上，无论是阻塞 I/O、非阻塞 I/O，还是基于非阻塞 I/O 的多路复用都是同步调用。因为它们在 read 调用时，内核将数据从内核空间拷贝到应用程序空间，过程都是需要等待的，也就是说这个过程是同步的，如果内核实现的拷贝效率不高，read 调用就会在这个同步过程中等待比较长的时间。
而真正的异步 I/O 是「内核数据准备好」和「数据从内核态拷贝到用户态」这两个过程都不用等待。
当我们发起 aio_read 之后，就立即返回，内核自动将数据从内核空间拷贝到应用程序空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，应用程序并不需要主动发起拷贝动作。过程如下图：

下面这张图，总结了以上几种 I/O 模型：

在前面我们知道了，I/O 是分为两个过程的： 1. 数据准备的过程 2. 数据从内核空间拷贝到用户进程缓冲区的过程
阻塞 I/O 会阻塞在「过程 1 」和「过程 2」，而非阻塞 I/O 和基于非阻塞 I/O 的多路复用只会阻塞在「过程 2」，所以这三个都可以认为是同步 I/O。
异步 I/O 则不同，「过程 1 」和「过程 2 」都不会阻塞。

用故事去理解这几种 I/O 模型

举个你去饭堂吃饭的例子，你好比用户程序，饭堂好比操作系统。
阻塞 I/O 好比，你去饭堂吃饭，但是饭堂的菜还没做好，然后你就一直在那里等啊等，等了好长一段时间终于等到饭堂阿姨把菜端了出来（数据准备的过程），但是你还得继续等阿姨把菜（内核空间）打到你的饭盒里（用户空间），经历完这两个过程，你才可以离开。
非阻塞 I/O 好比，你去了饭堂，问阿姨菜做好了没有，阿姨告诉你没，你就离开了，过几十分钟，你又来饭堂问阿姨，阿姨说做好了，于是阿姨帮你把菜打到你的饭盒里，这个过程你是得等待的。
基于非阻塞的 I/O 多路复用好比，你去饭堂吃饭，发现有一排窗口，饭堂阿姨告诉你这些窗口都还没做好菜，等做好了再通知你，于是等啊等（select 调用中），过了一会阿姨通知你菜做好了，但是不知道哪个窗口的菜做好了，你自己看吧。于是你只能一个一个窗口去确认，后面发现 5 号窗口菜做好了，于是你让 5 号窗口的阿姨帮你打菜到饭盒里，这个打菜的过程你是要等待的，虽然时间不长。打完菜后，你自然就可以离开了。
异步 I/O 好比，你让饭堂阿姨将菜做好并把菜打到饭盒里后，把饭盒送到你面前，整个过程你都不需要任何等待。


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        

                    
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/23/2020%E8%80%83%E7%A0%94%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88408%EF%BC%89%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">2020考研计算机（408）考试大纲</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-23</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/23/2020%E8%80%83%E7%A0%94%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88408%EF%BC%89%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">
                    <p>
                        
                            I 考试性质
计算机学科专业基础综合考试是为高等院校和科研院所招收计算机科学与技术学科的硕士研究生而设置的具有选拔性质的联考科目，其目的是科学、公平、有效地测试考生掌握计算机科学与技术学科大学本科阶段专业知识、基本理论、基本方法的水平和分析问题、解决问题的能力，评价的标准是高等院校计算机科学与技术学科优秀本科毕业生所能达到的及格或及格以上水平，以利于各高等院校和科研院所择优选拔，确保硕士研究生的招生质量。
II 考查目标
计算机学科专业基础综合考试涵盖数据结构、计算机组成原理、操作系统和计算机网络等学科专业基础课程。要求考生比较系统地掌握上述专业基础课程的基本概念、基本原理和基本方法，能够综合运用所学的基本原理和基本方法分析、判断和解决有关理论问题和实际问题。
III 考试形式和试卷结构
一、试卷满分及考试时间
本试卷满分为150分，考试时间为180分钟。
二、答题方式
答题方式为闭卷、笔试。
三、试卷内容结构
数据结构 45分
计算机组成原理 45分
操作系统 35分
计算机网络 25分
四、试卷题型结构
单项选择题 80分 (40小题，每小题2分)
综合应用题 70分
IV 考查内容
数据结构
【考查目标】
1.掌握数据结构的基本概念、基本原理和基本方法。
2.掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度与空间复杂度的分析。
3.能够运用数据结构基本原理和方法进行问题的分析与求解，具备采用C或C++语言设计与实现算法的能力。
一、线性表
(一)线性表的定义和基本操作
(二)线性表的实现
1.顺序存储
2.链式存储
3.线性表的应用
二、栈、队列和数组
(一)栈和队列的基本概念
(二)栈和队列的顺序存储结构
(三)栈和队列的链式存储结构
(四)栈和队列的应用
(五)特殊矩阵的压缩存储
三、树与二叉树
(一)树的基本概念
(二)二叉树
1.二叉树的定义及其主要特征
2.二叉树的顺序存储结构和链式存储结构
3.二叉树的遍历
4.线索二叉树的基本概念和构造
(三)树、森林
1.树的存储结构
2.森林与二叉树的转换
3.树和森林的遍历
(四)树与二叉树的应用
1.二叉排序树
2.平衡二叉树
3.哈夫曼(Huffman)树和哈夫曼编码
四、图
(一)图的基本概念
(二)图的存储及基本操作
1.邻接矩阵法
2.邻接表法
3.邻接多重表、十字链表
(三)图的遍历
1.深度优先搜索
2.广度优先搜索
(四)图的基本应用
1.最小(代价)生成树
2.最短路径
3.拓扑排序
4.关键路径
五、查找
(一)查找的基本概念
(二)顺序查找法
(三)分块查找法
(四)折半查找法
(五)B树及其基本操作、B+树的基本概念
(六)散列(Hash)表
(七)字符串模式匹配
(八)查找算法的分析及应用
六、排序
(一)排序的基本概念
(二)插入排序
1.直接插入排序
2.折半插入排序
(三)气泡排序(bubble sort)
(四)简单选择排序
(五)希尔排序(shell sort)
(六)快速排序
(七)堆排序
(八)二路归并排序(merge sort)
(九)基数排序
(十)外部排序
(十一)各种内部排序算法的比较
(十二)排序算法的应用
计算机组成原理
【考查目标】
1.理解单处理器计算机系统中各部件的内部工作原理、组成结构以及相互连接方式，具有完整的计算机系统的整机概念。
2.理解计算机系统层次化结构概念，熟悉硬件与软件之间的界面，掌握指令集体系结构的基本知识和基本实现方法。
3.能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，对一些基本部件进行简单设计;并能对高级程序设计语言(如C语言)中的相关问题进行分析。
一、计算机系统概述
(一)计算机发展历程
(二)计算机系统层次结构
1.计算机系统的基本组成
2.计算机硬件的基本组成
3.计算机软件和硬件的关系
4.计算机的工作过程
(三)计算机性能指标
吞吐量、响应时间;CPU时钟周期、主频、CPI、CPU执行时间;MIPS、MFLOPS 、GFLOPS、TFLOPS、PFLOPS。
二、数据的表示和运算
(一)数制与编码
1.进位计数制及其相互转换
2.真值和机器数
3.BCD码
4.字符与字符串
5.校验码
(二)定点数的表示和运算
1.定点数的表示
无符号数的表示;有符号整数的表示。
2.定点数的运算
定点数的位移运算;原码定点数的加减运算;补码定点数的加/减运算;定点数的乘/除运算;溢出概念和判别方法。
(三)浮点数的表示和运算
1.浮点数的表示
IEEE 754标准
2.浮点数的加/减运算
(四)算术逻辑单元ALU
1.串行加法器和并行加法器
2.算术逻辑单元ALU的功能和结构
三、存储器层次结构
(一)存储器的分类
(二)存储器的层次化结构
(三)半导体随机存取存储器
1.SRAM存储器
2.DRAM存储器
3.只读存储器
4.Flash存储器
(四)主存储器与CPU的连接
(五)双口RAM和多模块存储器
(六)高速缓冲存储器(Cache)
1.Cache的基本工作原理
2.Cache和主存之间的映射方式
3.Cache中主存块的替换算法
4.Cache写策略
(七)虚拟存储器
1.虚拟存储器的基本概念
2.页式虚拟存储器
3.段式虚拟存储器
4.段页式虚拟存储器
5.TLB(快表)
四、指令系统
(一)指令格式
1.指令的基本格式
2.定长操作码指令格式
3.扩展操作码指令格式
(二)指令的寻址方式
1.有效地址的概念
2.数据寻址和指令寻址
3.常见寻址方式
(三)CISC和RISC的基本概念
五、中央处理器(CPU)
(一)CPU的功能和基本结构
(二)指令执行过程
(三)数据通路的功能和基本结构
(四)控制器的功能和工作原理
1、硬布线控制器
2、微程序控制器
微程序、微指令和微命令;微指令的编码方式;微地址的形式方式。
(五)指令流水线
1、指令流水线的基本概念
2、指令流水线的基本实现
3、超标量和动态流水线的基本概念
六、总线
(一)总线概述
1、总线的基本概念
2、总线的分类
3、总线的组成及性能指标
(二)总线仲裁
1、集中仲裁方式
2、分布仲裁方式
(三)总线操作和定时
1、同步定时方式
2、异步定时方式
(四)总线标准
七、输入输出(I/O)系统
(一)I/O系统基本概念
(二)外部设备
1、输入设备：键盘、鼠标
2、输出设备：显示器、打印机
3、外存储器：硬盘存储器、磁盘阵列、光盘存储器
(三)I/O接口(I/O控制器)
1、I/O接口的功能和基本结构
2、I/O端口及其编址
(四)I/O方式
1、程序查询方式
2、程序中断方式
中断的基本概念;中断响应过程;中断处理过程;多重中断和中断屏蔽的概念。
3、DMA方式
DMA控制器的组成，DMA传送过程。
操作系统
【考查目标】
1.掌握操作系统的基本概念、基本原理和基本功能，理解操作系统的整体运行过程。
2.掌握操作系统进程、内存、文件和I/O管理的策略、算法、机制以及相互关系。
3.能够运用所学的操作系统原理、方法与技术分析问题和解决问题，并能利用C语言描述相关算法。
一、操作系统概述
(一)操作系统的概念、特征、功能和提供的服务
(二)操作系统的发展与分类
(三)操作系统的运行环境
1.内核态与用户态
2.中断、异常
3.系统调用
(四)操作系统体系结构
二、进程管理
(一)进程与线程
1.进程概念
2.进程的状态与转换
3.进程控制
4.进程组织
5.进程通信
共享存储系统;消息传递系统;管道通信。
6.线程概念与多线程模型
(二)处理机调度
1.调度的基本概念
2.调度时机、切换与过程
3.调度的基本准则
4.调度方式
5.典型调度算法
先来先服务调度算法;短作业(短进程、短线程)优先调度算法;时间片轮转调度算法;优先级调度算法;高响应比优先调度算法;多级反馈队列调度算法。
(三)同步与互斥
1.进程同步的基本概念
2.实现临界区互斥的基本方法
软件实现方法;硬件实现方法。
3.信号量
4.管程
5.经典同步问题
生产者-消费者问题;读者-写者问题;哲学家进餐问题。
(四)死锁
1.死锁的概念
2.死锁处理策略
3.死锁预防
4.死锁避免
系统安全状态，银行家算法。
5.死锁检测和解除
三、内存管理
(一)内存管理基础
1.内存管理概念
程序装入与链接;逻辑地址与物理地址空间;内存保护。
2.交换与覆盖
3.连续分配管理方式
4.非连续分配管理方式
分页管理方式;分段管理方式;段页式管理方式。
(二)虚拟内存管理
1.虚拟内存基本概念
2.请求分页管理方式
3.页面置换算法
最佳置换算法(OPT);先进先出置换算法(FIFO);最近最少使用置换算法(LRU);时钟置换算法(CLOCK)。
4.页面分配策略
5.工作集
6.抖动
四、文件管理
(一)文件系统基础
1.文件概念
2.文件的逻辑结构
顺序文件;索引文件;索引顺序文件。
3.目录结构
文件控制块和索引节点;单级目录结构和两级目录结构;树形目录结构;图形目录结构。
4.文件共享
5.文件保护
访问类型;访问控制。
(二)文件系统实现
1.文件系统层次结构
2.目录实现
3.文件实现
(三)磁盘组织与管理
1.磁盘的结构
2.磁盘调度算法
3.磁盘的管理
五、输入输出(I/O)管理
(一)I/O管理概述
1.I/O控制方式

I/O软件层次结构

(二)I/O核心子系统
1.I/O调度概念
2.高速缓存与缓冲区
3.设备分配与回收
4.假脱机技术(SPOOLing)
计算机网络
【考查目标】
1.掌握计算机网络的基本概念、基本原理和基本方法。
2.掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理解典型网络设备的工作原理。
3.能够运用计算机网络的基本概念、基本原理和基本方法进行网络系统的分析、设计和应用。
一、计算机网络体系结构
(一)计算机网络概述
1.计算机网络的概念、组成与功能
2.计算机网络的分类
3.计算机网络的标准化工作及相关组织
(二)计算机网络体系结构与参考模型
1.计算机网络分层结构
2.计算机网络协议、接口、服务等概念
3.ISO/OSI参考模型和TCP/IP模型
二、物理层
(一)通信基础
1.信道、信号、宽带、码元、波特、速率、信源与信宿等基本概念
2.奈奎斯特定理与香农定理
3.编码与调制
4.电路交换、报文交换与分组交换
5.数据报与虚电路
(二)传输介质
1.双绞线、同轴电缆、光纤与无线传输介质
2.物理层接口的特性
(三)物理层设备
1.中继器
2.集线器
三、数据链路层
(一)数据链路层的功能
(二)组帧
(三)差错控制
1.检错编码
2.纠错编码
(四)流量控制与可靠传输机制
1.流量控制、可靠传输与滑轮窗口机制
2.停止-等待协议
3.后退N帧协议(GBN)
4.选择重传协议(SR)
(五)介质访问控制
1.信道划分
频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理。
2.随即访问
ALOHA协议;CSMA协议;CSMA/CD协议;CSMA/CA协议。
3.轮询访问
令牌传递协议
(六)局域网
1.局域网的基本概念与体系结构
2.以太网与IEEE 802.3
3.IEEE 802.11
4.令牌环网的基本原理
(七)广域网
1.广域网的基本概念
2.PPP协议
3.HDLC协议
(八)数据链路层设备
1.网桥的概念和基本原理
2.局域网交换机及其工作原理。
四、网络层
(一)网络层的功能
1.异构网络互联
2.路由与转发
3.拥塞控制
(二)路由算法
1.静态路由与动态路由
2.距离-向量路由算法
3.链路状态路由算法
4.层次路由
(三)IPv4
1.IPv4分组
2.IPv4地址与NAT
3.子网划分与子网掩码、CIDR
4.ARP协议、DHCP协议与ICMP协议
(四)IPv6
1.IPv6的主要特点
2.IPv6地址
(五)路由协议
1.自治系统
2.域内路由与域间路由
3.RIP路由协议
4.OSPF路由协议
5.BGP路由协议
(六)IP组播
1.组播的概念
2.IP组播地址
(七)移动IP
1.移动IP的概念
2.移动IP的通信过程
(八)网络层设备
1.路由器的组成和功能
2.路由表与路由转发
五、传输层
(一)传输层提供的服务
1.传输层的功能
2.传输层寻址与端口
3.无连接服务与面向连接服务
(二)UDP协议
1.UDP数据报
2.UDP校验
(三)TCP协议
1.TCP段
2.TCP连接管理
3.TCP可靠传输
4.TCP流量控制与拥塞控制
六、应用层
(一)网络应用模型
1.客户/服务器模型
2.P2P模型
(二)DNS系统
1.层次域名空间
2.域名服务器
3.域名解析过程
(三)FTP
1.FTP协议的工作原理
2.控制连接与数据连接
(四)电子邮件
1.电子邮件系统的组成结构
2.电子邮件格式与MIME
3.SMTP协议与POP3协议
(五)WWW
1.WWW的概念与组成结构
2.HTTP协议

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        

                    
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/14/port%E2%80%9Cmac%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%E2%80%9D/">“mac虚拟机解决方案第二弹”</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-14</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/14/port%E2%80%9Cmac%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%AC%AC%E4%BA%8C%E5%BC%B9%E2%80%9D/">
                    <p>
                        
                            对于完全小白请先看一下鄙人的上一篇文章，brew的安装在进行后续操作。
最容易的请直接看3.
mac安装window虚拟机的三种方式，双系统硬盘安装，Parallels，virtaubox
Mac下安装Windows虚拟机有几种方式可以考虑1.双系统硬盘安装的方式，启动时选择不同的操作系统进去，相当于在苹果Mac笔记本硬件上安装了个Windows系统，不能直接切换，进去后操作Windows的体验比较好。需要下载安装特定的win10镜像，应用程序–&gt;实用工具–&gt;启动转换助理 然后按提示安装就可以了。图文介绍可以看这篇文章：https://zhuanlan.zhihu.com/p/34435136
2.使用收费虚拟机软件（Parallels 498元起），可以一键滑过去切换系统，体验也比较好，但开机启动会占Mac的内存资源，相当于启动了一个后台进程的软件。https://www.parallels.cn/Parallels Desktop 是功能最强大灵活度最高的虚拟化方案，无需重启即可在同一台电脑上随时访问Windows和Mac两个系统上的众多应用程序。从仅限于PC的游戏到生产力软件，Parallels Desktop都能帮您实现便捷使用。可以同时运行Windows和MacOS应用程序，直接从Mac dock启动Windows应用程序，无需重启。双系统文件随意拖动在Mac与Windows应用程序之间随意拖放文件快捷使用，无需本地拷贝文件即可存储，深度整合，手势共用，云端共享。操作简单 无缝对接安全便捷的新建向导自动查找操作系统，融合模式(Coherence)不使用Windows界面也可轻松切换各个应用程序，无缝对接。Parallels Toolbox 是Mac平台上的一款PD虚拟机快捷的实用工具集合工具
3.使用免费虚拟机软件virtualbox虚拟机，在虚拟机软件里面打开，功能比较弱，体检比较差，也不太稳定，经常出现需要重新安装系统的问题，只能当测试用或者临时用一下。
使用免费虚拟机软件virtualbox虚拟机安装方法：1.安装完成brew后可以使用命令安装免费的virtualbox虚拟机PS:由于源在国外问题，brew下载的速度很慢经常会导致下载超时失败，建议改成国内镜像或者fq后执行brew cask install virtualboxbrew cask install virtualbox-extension-pack

2.安装完成虚拟机后下载一个ISO镜像，本人测试用迅雷下载了几个都不能用，到微软官方上下载了一个才安装成功了
3.下载完ISO镜像后打开virtualbox创建虚拟机就可以了

 

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/14/portmac%E7%9A%84brew%E5%AE%89%E8%A3%85%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/">mac的brew安装快捷方式</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-14</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/14/portmac%E7%9A%84brew%E5%AE%89%E8%A3%85%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/">
                    <p>
                        
                            介于网上误人子弟，及其不负责任的brew安装方式讲解
最离谱的看到一个老哥安装brew写了洋洋洒洒的2000多字。
所以为了各位刚使用的朋友谋福利，这里只需要一行代码，在terminal执行即可
一键解君愁。
在网上搜了很多brew安装方式，包括使用官网的方式都安装报错Failed to connect to raw.githubusercontent.com port 443: Connection refused
然后找了好久终于找到一个安装成功。
安装方式
/bin/zsh -c “$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;
你没有看错，把这行代码执行就可。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/13/mac%E4%B8%8A%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/">mac上安装虚拟机</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-13</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/13/mac%E4%B8%8A%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/">
                    <p>
                        
                            应某位学弟的要求，鄙人今晚与图书馆写了此篇博文。
软件选择目前我知道的Mac虚拟机：
Parallels Desktop：收费，基本无序列号资源；但据说好用、强大，对Win系统多了很多优化。VMWare Fusion：老牌虚拟机软件，Mac上也做的非常不错。VirtualBox：开源，免费，但好像不够强大。在找了很久 Parallels Desktop 的资源，而又无功而返后，最终决定使用 VMWare Fusion。
开门见山地说，附上破解版本链接 https://www.xxmac.com/mac/xuniji

运行效果
· 运行速度不稳定
12&gt; 这里的不稳定是每次之间，不是时快时慢。&gt; 刚开机时较慢，运行一段时间后速度较快。


u1s1比便宜的商务本流畅多了 （4000¥以下的）
系统之间文件转换方便
适用情况很广，我的wtg就是使用虚拟机安装的
总体体验感觉不错

安装过程安装过程非常简单，几乎全部傻瓜式操作 1. 下载虚拟机软件 推荐：Parallels Desktop
链接： mac志

下载镜像



获得方式同上，注意要下载可以用于虚拟机的版本
如果使用上面推荐的这款软件会自带镜像
安装虚拟机软件



下载好之后应该得到中间这个，运行即可，里面全部中文界面，自带win10和unbuntu等等虚拟机镜像，按照提示操作即可
完成后就能看到上面另外的两个图标了。做什么用的？就是字面意思。


双红杠就是这款虚拟机应用的标志
\4. 节约空间 虚拟机支持在移动硬盘里运行，如果在安装时可以选择位置，直接设置到外部介质即可。如果没有机会选择，就要自己下载好镜像存储在移动硬盘中，安装时倒入虚拟机。（好像直接安装到内置硬盘中然后把系统文件直接拖到外部介质再重启虚拟机导入系统也可以，我可能就是这么操作的）
为什么今年我放弃虚拟机不是因为不好用，而是因为移动的业务效能过高了。
以上不行则使用方案二
大部分Mac用户大部分都是通过Parallels Desktop或者VMware Fusion Pro安装虚拟机，可两款虚拟机价值不菲，但是今天小编为大家带来VMware虚拟机免费获取教程，仅限个人或者非商业用途使用！


Macv.comVMware Fusion Pro 12 Mac(vm虚拟机) 支持11.0 Big Sur614.88 MB2020.11.20简体中文VMware Fusion 12最新推出的最新版本虚拟机，VMware Fusion 11Mac版可以完整支持 Windows 10、OS X El Capitan 和最新的 Retina Mac 产品，当然还支持微软的 Cortana！下载

Macv.comParallels Desktop 16 for mac(最好用的虚拟机软件)支持big sur280.8 MB2020.12.16简体中文Parallels Desktop 16被称为 macOS 上最强大的虚拟机软件。可以在 Mac 下同时模拟运行 Win、Linux、Android 等多种操作系统及软件而不必重启电脑，并能在不同系统间随意切换。下载
VMware虚拟机免费获取教程
先用谷歌浏览器打开 https://www.vmware.com/ 进入VMware虚拟机的官网，点击Downloads—Fusion

转至虚拟机下载页面，点击GO TO DOWNLOADS

点击DOWNLOAD NOW

需要登陆VMware的账户，可以自己申请一个。

注册完成之后登陆就可以完成下载软件。软件下载完成后打开，双击VMware Fusion.app进行安装

输入电脑密码，点击OK

来到VMware注册页面，点击获取免费的许可证密钥

跳转到以下界面

如果跳转的是中文版的VMware官网页面，请将地区更改为美国再重新点击获取免费的许可证密钥

登陆上自己刚注册的账户，然后选择License &amp; Download就可以查看自己的注册密钥了

将获取的注册密钥复制到指定位置点击继续，VM虚拟机就可以免费使用了！


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/02/iOS%E3%80%81macOS%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">iOS、macOS系统应用管理机制</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-02</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/02/iOS%E3%80%81macOS%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/">
                    <p>
                        
                            *iOS、macOS系统应用管理机制*
　　苹果系统包括：iOS、macOS、watchOS、tvOS。应用软件的生命周期为：开发、上线、安装、使用、卸载。这篇文档将从应用生命周期的各个环节介绍苹果系统对应用的管理机制，主要详细介绍iOS和macOS，watchOS与tvOS由于用户数量少，以及流程与iOS相似度较高，只作了简单介绍。
iOS一、开发注册账号：
　　单纯开发是不用付费的，使用模拟器就可以。如果要真机调试，或者提交appstore，需要申请开发者帐号。
 
　　需要提交：1、注册一个苹果账号作为开发者账号。2、个人或企业的姓名、地址、联系方式等相应资料。3、能够做美金结算的信用卡账。4、支付99美金给苹果公司。
　　另外，申请企业账号需要提供DUNS（邓白氏编码）以及税务等相应资料。D-U-N-S Number 是一组唯一的九位数字，用于检查所在组织的身份和法人实体状态。如果未拥有此识别码，需要将信息提交给 Dun &amp; Bradstreet，以获取一个免费的 D-U-N-S Number。
　　Apple 开发者到期 App 是会下架，但是已经安装 App 的用户，手机仍能使用App，App Store里面搜索不到。续费 Apple 开发者后，App 会在当天上线App Store。Apple开发者到期时不能转让App。
开发工具：
　　苹果应用开发需要使用mac系统下的Xcode，使用Objective-C和Swift语言。Xcode由苹果公司开发的集成开发环境，免费对用户使用，可以开发iOS、macOS、watchOS、tvOS四个系统应用。
二、上线应用开发完成后，如要发布上架App store，大致经过以下8个步骤。
　　1. 登录Apple开发者中心网站，选择certificates，Identifiers and profiles，在APP IDs选项里注册一个APP ID，用于标识一个或一组APP，需要填写APP的描述和需要注册的服务功能。
　　2.创建开发证书，证书分为iOS Development（开发证书）和iOS Distribution（发布证书），开发证书用于真机调试，有一年使用期限。发布证书用于APP的发布。
　　3.配置iOS Provisoning Profiles（debug）描述文件，Provisoning Profiles是苹果签名认证的Plist文件，列举了开发证书、APP ID、以及授权运行设备的UDID（为一个设备的唯一标识）。
　　4.在Xcode中进行应用证书注册并打包APP。在工程里将Provisoning Profiles配置导入，完成后就可以打包APP了，导出APP包。
　　5.真机调试。可以在授权的设备上进行真机调试，将打包导出的APP包安装于设备上，安装时系统会对开发证书进行认证，成功后app会安装在设备上，可以在设备上对app进行测试。
　　6.真机测试没问题后，可以对APP进行上架发布。这里需要进入开发者中心创建发布证书，并配置Provisoning Profiles 描述文件。
　　7.需要在itunes connect 上创建本应用的项目。在开发者中心的itunes connect管理界面创建一个新APP项目，填写APP的相关信息包括描述、销售范围、版本信息、关键词等。
　　8.提交审核。需要提供一个测试账号用于审核人员进行测试。应用提交之后审核人员对应用进行审核。审核针对安全、性能、业务、设计、法律五个层面。
　　　　安全：不包含不良内容，不造成人身安全隐患、数据安全、不得在指定容器范围外读写数据、不具有特殊权限
　　　　性能：APP完成度、硬件兼容性、能耗、占用系统资源量、网络性能
　　　　业务：付款、广告合乎标准
　　　　设计：不涉抄袭、有价值、
　　　　法律：隐私、知识产权
　　苹果官方要求，开发和上线应用必须通过Xcode这一集成开发工具，也就是只能在mac电脑下完成。但如果想在windows环境下完成开发，也可以通过一些其它途径。借助LBuilder、HBuilder、APICLoud、APPCan等工具，可以把网站打包成APP，之后通过上架辅助软件Appuploader进行windows下APP的上架。Appuploader是ios上架辅助工具，可以直接得到.p12和.mobileprovision证书文件，上传ipa到App store，打破了上架ios只能在苹果电脑用Xcode的限制，使用费用100元/年。
三、安装　　在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。
ios****正规的应用安装方式分为三种：
1.通过APP store安装
　　对于通过APP store安装的应用，iOS为了确保所有的应用程序没有被修改，要求必须使用苹果颁发的证书对可执行代码进行签名。开发者使用苹果颁发的发布证书签名后，将应用题叫道APPstore审核，审核成功后，苹果使用其私钥对程序进行签名。用户从APPstore下载安装应用，iOS调用系统进程获取provisioning profile文件，对应用程序进行证书校验。
2.开发 App 时直接把开发中的应用安装进手机进行调试，即在上线时的真机调试
　　开发时安装APP，它有两个需求，1）安装包不需要传到苹果服务器，可以直接安装到手机上。2）苹果必须对这里的安装有控制权，包括a.经过苹果允许才可以这样安装。b.不能被滥用导致非开发app也能被安装。苹果使用双层签名的机制，
　　1）在你 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。
　　2）苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。
　　3）把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。
　　4）在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。
　　5）在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为embedded.mobileprovision，把 APP 安装到手机上。
　　6）在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证embedded.mobileprovision的数字签名是否正确，里面的证书签名也会再验一遍。
　　7）确保了embedded.mobileprovision里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。

3.企业内部分发，可以直接安装企业证书签名后的 APP
　　企业内部应用，即只在企业部门和员工内部使用、不对外公开的应用。苹果提供了专门的In-House证书用来发布这种应用，可以分发给任意的手机，只要通过一个URL即可下载安装，不用上传到App Store审核。In-House应用，有时需要根据部门需求进行版本的快速迭代，因为不需要App Store审核，所以可以做到随时修改，随时发布，节省了大量的时间。
　　在打包安装时同样需要创建证书，证书类型为In-House型，之后创建配置文件(Distribution Provisioning Profiles)，过程和其他证书创建过程类似。在Xcode中导入配置文件，打包程序，可以导出ipa和plist文件。Plist文件中包含ipa的URL、安装时显示的 icon 的url、bundle id、版本号、安装前的提示信息。将plist文件上传至服务器，企业员工在safari浏览器中输入链接即可安装。Safari操作的具体流程是：
　　1）Safari解析输入的字符串，找到plist文件
　　2）根据plist文件里面提供的信息下载并安装ipa包，还会访问大小图标，大小图标在ipa包正在下载时显示，当下载完毕后显示程序自带的图标
　　3）下载安装后，如果想打开程序还需要在手机 设置-&gt;通用-&gt;描述文件与设备管理，在“企业级应用”分组下，点击 信任 开发者的证书里面选择相应的证书信任后，方可打开程序。
　　综上，3种安装方式归根结底，都是通过验证安装程序的provisioning profile文件。安装应用程序时，Provisioning Profile 文件被拷贝到 iOS 设备中，运行该 iOS App 的设备通过它来认证安装的程序。Provisioning Profile 把AppID、签名证书、设备授权这些信息全部打包在一起，方便我们在调试和发布程序打包时使用。这样，只要在不同的情况下选择不同的 Provisioning Profile 文件就可以了。
　　除了在正规途径下安装应用以外，通过“打破”原有权限，获取更高权限，可以实现脱离官方平台，自由安装第三方的应用，即我们口中的“越狱”。
　　iOS系统具有封闭性，通过代码签名机制限制未经签名的代码在iOS系统中执行。用户不能访问系统资源，也无权修改，只能使用苹果颁发证书的正规途径的应用或程序接口完成系统允许的操作。越狱后，用户可以获得权限访问与修改系统文件，继而获得更多的权限，完成之前未被iOS允许的功能。越狱的原理是通过漏洞。至少需要2个漏洞，第一个漏洞用来完成专有代码执行，第二个漏洞用来使内核的安全措施失效，提升权限。
　　越狱之后安装应用可不通过APP store，有一些越狱者制作的类似APP store的应用安装商店，APP store默认安装位置为/var/mobile/Applications目录里，越狱后可安装在根目录下，所以墙纸、主题、铃声等一些个性化应用在越狱后可以得到安装。
四、使用iOS程序5****种状态：
\1. Not running：
　　应用还没有启动，或者应用正在运行但是途中被系统停止
2.Inactive:
　　当前应用正在前台运行，但是并不接收事件（当前或许正在执行其它代码）。一般每当应用要从一个状态切换到另一个不同的状态时，中途过渡会短暂停留在此状态。唯一在此状态停留时间比较长的情况是：当用户锁屏时，或者系统提示用户去响应某些（诸如电话来电、有未读短信等）事件的时候。
3.Active:
　　当前应用正在前台运行，并且接收事件。这是应用正在前台运行时所处的正常状态。
4.Background:
　　应用处在后台，并且还在执行代码。大多数将 要进入Suspended状态的应用，会先短暂进入此状态。然而，对于请求需要额外的执行时间的应用，会在此状态保持更长一段时间。另外，如果一个应用要求启动时直接进入后台运行，这样的应用会直接从Notrunning状态进入Background状态，中途不会经过Inactive状态。比如没有界面的应用。注此处并不特指没有界面的应用，其实也可以是有界面的应用，只是如果要直接进入background状态的话，该应用界面不会被显示。
5.Suspended:
　　应用处在后台，并且已停止执行代码。系统自动的将应用移入此状态，且在此举之前不会对应用做任何通知。当处在此状态时，应用依然驻留内存但不执行任何程序代码。当系统发生低内存告警时，系统将会将处 于Suspended状态的应用清除出内存以为正在前台运行的应用提供足够的内存。
应用启动过程：
1、执行main函数
2、在此方法中调用UIApplicationMain
2.1 创建UIApplication对象（UIApplication对象是应用程序的象征，一个UIApplication对象就代表一个应用程序。每一个应用都有自己的UIApplication对象，而且是单例的，如果试图在程序中新建一个UIApplication对象，那么将报错提示。一个iOS程序启动后创建的第一个对象就是UIApplication对象，且只有一个。利用UIApplication对象，能进行一些应用级别的操作。）
2.2 创建UIApplication的delegate对象。（UIApplication Delegate的作用是当应用程序发出一系列系统事件如来电或锁屏等，做出相应的反应。新建完项目，都有个带有“AppDelegate”字眼的类，它就是UIApplication的代理,AppDelegate默认已经遵守了UIApplicationDelegate协议，已经是UIApplication的代理。系统事件如程序降将要启动、程序启动完成、程序进入后台、程序进入前台、程序退出等。）
2.3 开启消息循环
3、delegate对象开始监听系统事件
3.1 app启动完成后会调用delegate对象的程序加载完成的方法
3.2 如果app的plist设置了main storyboard 会创建UIWindow对象(如 果没有设置则不创建)
3.3 创建main storyboard中绑定的controller对象(stroyboard中箭 头指向的控制器)
3.4 设置给window对象的rootViewController
3.5 设置window对象可见

屏幕响应顺序
　　iOS和安卓系统具有不同的屏幕响应顺序，IOS对屏幕的响应顺序是：触摸→媒体→服务→架构，而安卓是：程序→框架→屏幕显示资源→架构。所以在视觉效果上，iOS会有更流畅的感觉。
后台管理机制
　　从iOS 3开始，苹 果为iPhone引进了push notification，不启动应用也 能收到推送消息，原理是 消息由APNS(Apple Push Notification Service， Apple Push服务器)统一管 理，随着iOS 4的发布，iOS也开始有了 多任务功能，当你点击H o m e键后，当前 程序转入后台(iOS 4之前按Home键就 直接干掉应用了)，后台应用以墓碑的形 式(退出前的状态)保存在内存中，用户 可以快速恢复。但是苹果对后台的限制非 常严格，只有一些特殊应用可以在后台 真正运行，比如音频播放类、VoIP类、 newsstand、位置服务等。
　　如果不做任何配置的话，你的应用最 多只能在后台运行5秒，之后就会被挂起 (存于内存但不运行)，如果你配置了后 台运行(如需下载)，大概在594秒(9.9 分钟)时进程停止，程序同样也会被挂 起，一旦系统需要内存了，最早的后台进 程就会被杀掉以释放内存。
　　从 iOS 7 开始， 一旦手机锁屏， 后台应用将会很快被暂停， 之后当系统被唤醒时，那些暂停的后台应用会一起继续运行。现在的iOS后台管理很智能， 他会记忆你每天什么时段打开什么应用， 经过一段时间后， 他会在适当时间唤醒相应的应用。iOS7新增三种后台模式：
Baxkground Fetch 后台应用刷新
　　iOS 7 之前的应用必须在打开时才能联网获取数据， 而它可以让应用在后台直接获取数据。
Silent Remote Notifications 静默推送唤醒
　　iOS 7 之前当收到消息后， 只有打开应用才能从APNS获取推送的具体消息， 现在在收到消息后， 会自动唤醒相应的APP ， 让该APP在后台获取消息， 再通知用户。
Background Transfer Servce 后台传输
　　以前一旦下载被转移到后台最多只能持续运行549秒（9.9分钟）， 现在所有的下载任务会交给系统独立的进程去完成， 不管APP在前台、挂起还是被杀掉， 下载都在继续进行。
自动清理机制
　　iOS系统在安装应用或者使用过程中存储空间不足时，会自动清理一些应用的缓存以释放空间。

APP****更新推送
　　当app有新版本时，可以在APP store里更新应用。APP在安装的时候，会在数据库里appid对应的列表下新增版本号的关键字。用户在【更新】界面刷新操作后，发送请求查询用户表，并关联APP信息表获取到用户安装过的每一款APP的最新版本号列表。然后把最新版本号列表中的app版本号，与本地的app版本进行比对，如果最新版本号列表中的版本号大于本地版本号，则会有更新提示。
五、卸载iOS****文件目录结构：
/：为根目录
Applications： 存放所有的系统 APP 和来自 Cydia 的 APP,不包括从 App Store 下载的APP
Developer： 供开发者使用
Library：系统资源，用户设置
System：系统的重要组成部分
User：用户目录，实际指向 /var/mobile
bin：存放用户级可执行文件，如 ls、mv 等
dev：设备文件
etc：存放系统脚本、hosts 配置、SSH 配置文件等
sbin：存放系统二进制文件
usr：用户工具和程序
var：变量文件，在正常运行的系统中其内容不断变化的文件
　　应用都是安装在/var/mobile/Applications目录下，且应用沙盒机制，每一个应用分配自身的存储空间，不能越界访问。应用程序沙盒目录下有三个文件夹Documents、Library（下面有Caches和Preferences目录）、tmp。Documents：保存应用运行时生成的需要持久化的数据iTunes会自动备份该目录。Library/Caches：一般存储的是缓存文件，例如图片视频等，此目录下的文件不会再应用程序退出时删除，在手机备份的时候，iTunes不会备份该目录。Library/Preferences：保存应用程序的所有偏好设置iOS的Settings(设置)，iTunes会自动备份该文件目录下的内容。tmp：临时文件目录，在程序重新运行的时候，和开机的时候，会清空tmp文件夹。
　　iOS 中 app 对本地存储只能访问到自己的根目录，再往上就没有权限了。在删除应用时，app自身的存储空间的根目录会直接删除，在机制内不会留下残留文件。
Mac OS　　Mac OS是基于Unix内核的图形化操作系统；由苹果自行开发，不对外销售，一般情况下在普通PC上无法安装，只安装于苹果的设备中。mac OS虽然也对应用有较严格的管理机制，但与手机端iOS系统相比，用户具有更多的权限。
一、开发　　mac OS应用的开发过程与iOS的开发类似，需要付费注册开发者账号，同样使用Xcode作为开发工具。
二、发布　　应用开发完成后，发布方式与iOS下有所不同。除了在app store线上发布，还可以在平台以外发布。mac开发下的证书有5种：
开发证书：
（1）Mac Development：用于开发和测试的证书，跟iOS development证书一样；运行在指定设备上需要把设备的UUID添加到devices里面去。
发布证书：
Mac App Store
（2）Mac App Distribution：这个用于 Xcode 自己把.app 文件上传到 Mac App Store，具体的上线过程与iOS应用类似。
（3）Mac Installer Distribution：这是用于开发者自己把.app 文件打包成 .pkg 文件，再用 Xcode 自带的 App Application Loader 上传到 Mac App Store ，可用于上传到store前模拟真实的store环境。
Developer ID
（4）Developer ID Application：这个用于开发者使用开发者帐号签名，导出一个线下发布版本的 .app 文件，但是由于脱离了苹果的 Mac App Store，还是加上许可协议打包成 .pkg 文件再发布比较好，给用户一个决定是否安装的机会。这就要用到第5个证书。
（5）Developer ID Installer：用于开发者打包，同时加上开发者帐号签名，打包生成一个.pkg的安装包，可以装到任意一台Mac电脑上执行安装过程。
　　5种证书，开发证书用于开发和测试，发布证书就对应着app store和线下两种发布形式。根据需要的发布形式创建对应的证书，证书的创建过程可参考iOS应用的证书创建，发布的具体过程可以按照官方文档和Xcode的提示一步步来。当然如果不想用证书也不担心用户拒绝来源不明的应用的话，也可以不用任何证书签名打包应用，用默认的签名方式就可以。

三、安装mac OS上对于应用的不同发布形式，也有不同的安装方法，可以分为三种。
　　1.对于app store上的应用，即上一部分的（2）（3）发布方式，用户可以直接登录自己的苹果账户，进行购买或者获取资源下载，对软件的购买在平台完成，苹果会抽取一部分分成。app store上的应用经过苹果内部人员的审核和测试，本身会具有更高的完整度、质量和运行稳定性。但是国内应用的很多软件app store都没有，需要线下的方式进行安装。
　　2.第二种安装方式是线下的.app格式的应用的安装，即上一部分的（4）发布方式。这种用户可以自行从网上搜索下载源，一般下下来的安装文件是一个.dmg格式的磁盘映像，dmg 是苹果的压缩镜像文件，类似于 Windows 下的 ISO，双击打开后会给系统挂上一个类似移动硬盘的虚拟磁盘，安装完后可以右键弹出。它是 macOS 应用软件通用的打包格式，里面一般包含“应用程序名.app”的图标和一个应用程序文件夹（/Applications）快捷方式。直接将图标拖曳至应用程序文件夹，即可完成安装，非常快捷。
　　3.第三种是.pkg安装包的安装，即上一部分的（5）发布方式。.pkg属于系统级软件的安装程序，类似于windows中的.exe安装程序，会阅读许可协议并选择安装位置、安装内容，一般会修改系统配置，权限较高，需要sudo授权。
　　对于一些来源不明或没有证书的应用，在打开安装程序时有时会出现“文件已损坏，打不开”。这是由于系统的安全机制对来源不明的软件的限制。可以通过在命令行里修改权限，在系统偏好设置的安全性与隐私设置里，改成允许任何来源的应用。


　　有时还会提示“来自身份不明的开发者”，这时同样在偏好设置的安全性与隐私设置里，可以看到要打开的应用被阻止的提示，点击“仍要打开”即可。


　　苹果的应用为.app的格式，既是一个包，包含应用的全部内容，可以右键显示包内容，对里面的文件或配置进行修改（具有比iOS更高的权限），同时也是一个可执行文件，安装在Applications文件夹后会自动出现在系统的Launchpad（启动台）里。
四、卸载　　mac上对于应用的卸载，由于安装方式不同，卸载方式也不同。app store里安装的应用，类似于iOS，在Launchpad（启动台）里长按图标，点叉号即可卸载。线下的app store平台外自己安装的应用极少数会自带卸载程序，多数直接在Applications文件夹里右键删除即可。只是对于.pkg安装包安装的应用，由于有时具有较高权限，可能会修改系统配置，所以删除应用后有时可能会有卸载残留，可以通过第三方卸载软件或手动删除。
watchOS　　watchOS是苹果公司基于iOS 系统开发的一套使用于Apple watch的手表操作系统。它的应用的开发与上线与iOS相同，用户只能通过App store来安装应用。在2019年6月之前，对应用程序的安装不能在apple watch上直接进行，只能结合iphone使用。连接之后在iPhone上打开Apple Watch应用程序，来安装需要的表上应用。安装完成后，会首先在iPhone上面显示。需要说明的是，Apple Watch APP应用程序都是必须要配合iPhone使用的，因此所有安装到Apple Watch上面的应用程序，都会同时安装到iPhone上。2019年6月之后发布的新的watchOS系统，自带app store，不用再连接iphone来安装应用，可以直接在app store里获取安装。
　　卸载应用也是两种方式，既可以在apple watch内直接卸载，也可以与iPhone配对，通过iPhone里的apple watch应用来管理手表应用。
tvOS　　tvOS是苹果公司专门为Apple TV设计的操作系统，基于 iOS。2016年3月发布了 tvOS 9.2 操作系统。Apple TV是苹果公司推出的一款高清电视机顶盒产品，用户可以通过Apple TV在线收看电视节目，也可以通过Airplay功能，将iPad、iPhone、iPod和PC中的照片、视频和音乐传输到电视上进行播放。tvOS也可以安装一些应用，具有独立的应用生态，通过自带的app store进行搜索和安装。
　　tvOS应用的开发与发布也与iOS类似，需要注册成为开发者，使用官方的开发工具xcode进行开发，开发与发布同样需要创建证书。具体过程均与iOS相同。
　　在国内目前用户不多，不能直接收看国内的有线卫视节目，需要联网安装app来收看电视台。
苹果系统与其他系统比较iOS与macOS对比　　两个系统都是苹果自主研发的系统，但我们也可以看出，macOS的用户比起iOS拥有更广的权限，可以访问系统资源，读写系统目录、系统文件，也可以访问应用内部目录，对其配置文件进行修改，还可以下载安装来自任何来源的应用。相比之下，iOS的系统生态就更加封闭，使用者无法查看系统文件资源，也不能访问应用内部，只能通过应用的接口来使用和管理应用。而对于广大苹果手机用户而言，他们所使用的唯一的应用安装方式就是通过官方的APP store。
iOS系统应用与安卓对比　　具有安装来源不同、用户权限不同、运行机制不同、后台机制不同、响应处理指令权限不同几大区别。相比之下优点：1）所有上线应用经过审核，具有更高的稳定性、流畅度、安全指数、优化性，且可以保护版权，安卓应用开发者随意开发，参差不齐。2）应用具有较低的权限，可以更好的保护用户隐私，相比之下，安卓许多应用如不开放权限则不让用户使用。3）通过优先响应屏幕和独特的对内存管理的方式使其具有更流畅的运行效果。4）iOS软硬件垂直整合，只运行在苹果设备上，安卓可以运行在多种设备上，所以iOS上的应用有更好的兼容性。
　　缺点：1）安卓系统开放，且开发门槛低，所以资源多，开发者多，创新也多。2）安卓系统用户权限大，所以操作更灵活，也更加个性化。
windows与macOS应用对比　　开发门槛不同：mac应用开发成本大，windows程序任意开发者均可以免费开发。
　　安装来源不同：windows可以随意安装程序，mac的可以通过app平台或平台之外，均会验证证书，质量更高。
　　安装方法不同：windows安装包进行安装，mac可以应用商店直接获取，或者直接复制app到应用程序，或者安装包安装。
　　应用文件结构不同，windows除了安装根目录，还会写入注册表信息，通过exe执行文件启动。mac的app文件既是整个应用包，同时是启动入口。
　　卸载方式不同：windows通过卸载程序，mac直接删除。
苹果系统中的安全机制Apple ID双重认证　　首次登录一台新设备时，除输入密码外，还需要在信任设备上的授权才可以登录。输入验证码后，即确认信任这台新设备。由于只输入密码不再能够访问帐户，因此双重认证显著增强了 Apple ID 以及所有通过 Apple 储存的个人信息的安全性。登录成功后，系统将不会再次要求信任设备的验证，除非完全退出登录帐户、抹掉设备数据或出于安全原因而需要更改密码。受信任设备是已使用双重认证登录的设备，可以是装有 iOS 9 及更高版本的 iPhone、iPad 或 iPod touch 或者装有 OS X El Capitan 及更高版本的 Mac。受信任电话号码是指可通过短信或自动语音电话接收验证码的号码。您必须至少验证一个受信任电话号码才能注册双重认证。
代码签名　　苹果也是通过代码签名来保证每一个安装到iOS上的APP都是经过苹果官方允许的，防止盗版软件、病毒入侵、静默安装等。苹果也是通过代码签名来保证每一个安装到iOS上的APP都是经过苹果官方允许的，防止盗版软件、病毒入侵、静默安装等。
可信引导　　iOS设备开机后采用一种称为可信引导的方式进入系统。引导过程中，安全只读内存 (SecureROM) 是首先被引导的部分，其中嵌入了根证书 (Root Certificate)用以检查下一步所加载组件的RSA签名。 在随后的每个步骤中，系统校验下一步骤所要加载组件的 RSA 签名。这一信任链 (Chain of Trust) 保证了系统启动过 程中的所有组件没有被破坏和修改。
沙盒机制　　沙盒也叫沙箱，英文standbox，其原理是通过重定向技术，把程序生成和修改的文件定向到自身文件夹中。在沙盒机制下，每个应用程序都有自己的存储空间，程序之间的文件夹不能互相访问。iOS系统为了保证系统安全，采用了这种机制。iOS 应用程序在安装时，会创建属于自己的沙盒文件，应用程序不能直接访问其他应用程序的沙盒文件，当应用程序需要向外部请求或接收数据时，都需要经过权限认证，否则，无法获取到数据。应用程序中所有的非代码文件都保存在沙盒中，比如图片、声音、属性列表，sqlite数据库和文本文件等。
数据加密　　iOS4 及以后的系统使用数据加密机制来保护文件系 统中的系统和数据分区。系统和数据分区中的数据将由一 个基于硬件设备的密钥进行加密。在 iPhone3GS 以后的设 备上，该密钥存储于一个AES加密加速硬件上。这个基 于硬件的密钥不能被 CPU 所访问，只有在加解密时才能 由该加速器获取。通过这种机制，直接从硬盘上被取走的 原始数据就无法被正确解密。同时，数据加密机制还提供 了多种加密策略供应用程序选择。应用程序可以选择对一 些敏感文件使用NSFileProtectionComplete 策略而不是默认 的 NSFileProtectionNone 策略加密数据。
　　疯狂肆虐的电脑病毒几乎都是针对Windows的，由于MAC的架构与Windows不同，沙盒机制、使用人数少、研究成本大、对应用安装的管控力度，所以很少受到病毒的袭击。
参考资料【1】Bucicoiu M, Davi L, Deaconescu R, et al. XiOS: Extended application sandboxing on iOS[C]//Proceedings of the 10th ACM Symposium on Information, Computer and Communications Security. ACM, 2015: 43-54.
【2】Mohamed I, Patel D. Android vs iOS security: A comparative study[C]//2015 12th International Conference on Information Technology-New Generations. IEEE, 2015: 725-730.
【3】Ahmad M S, Musa N E, Nadarajah R, et al. Comparison between android and iOS Operating System in terms of security[C]//2013 8th International Conference on Information Technology in Asia (CITA). IEEE, 2013: 1-4.
【4】安迪. iOS真的是“伪后台”吗?[J]. 个人电脑, 2016(2):86-88.
【5】刘乐廷, 李敬兆, LIULe-ting, et al. IOS内存开发管理机制的研究[J]. 计算机与现代化, 2013(3):196-199.
【6】陈佳霖, 王轶骏, 薛质. iOS系统数据安全研究[J]. 信息安全与通信保密, 2012(8):100-102.
【7】Apple官方开发者账户帮助https://help.apple.com/developer-account/?lang=zh-cn#/dev7a05c5ce1
【8】iOS最新应用上架App Store流程https://www.jianshu.com/p/e5ac7b05750a
【9】Apple Developer-App Store 审核指南https://developer.apple.com/cn/app-store/review/guidelines/#in-app-purchase
【10】windows使用Appuploader上架应用https://www.jianshu.com/p/6f50130b6950
【11】苹果企业账号发布APP详解https://www.jianshu.com/p/0418f5051185
【12】Provisioning Profile https://www.jianshu.com/p/0affef7cef69
【13】iOS包签名原理https://www.jianshu.com/p/b7416aef5f5c
【14】Mac App 发布的最后 1km https://sspai.com/post/40269

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86/" rel="tag">计算机常识</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/12/02/2013-12-02-jdk-version-switch-in-mac/">MAC下JDK版本的切换</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-12-02</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/12/02/2013-12-02-jdk-version-switch-in-mac/">
                    <p>
                        
                            原来系统里安装的是1.6的，这是最后一个由提供的jdk，1.7开始Oracle提供mac平台的jdk了。
现在安装了1.7的，觉得需要进行多个版本的切换，以下是方法：
临时更改版本（单会话有效）首先运行：
1/usr/libexec/java_home
可以知道当前环境的JAVA_HOME是：
1/Library/Java/JavaVirtualMachines/jdk1.7.0_45.jdk/Contents/Home

这是1.7的JAVA_HOME，我们可以使用 -v 标识来获取1.6的JAVA_HOME
123/usr/libexec/java_home -v &#x27;1.6*&#x27;/Library/Java/JavaVirtualMachines/1.6.0_65-b14-462.jdk/Contents/Home

然后我们可以手动地设置JAVA_HOME
123456789export JAVA_HOME=`/usr/libexec/java_home -v &#x27;1.6*&#x27;`java -versionjava version &quot;1.6.0_65&quot;Java(TM) SE Runtime Environment (build 1.6.0_65-b14-462-11M4609)Java HotSpot(TM) 64-Bit Server VM (build 20.65-b04-462, mixed mode)

所有会话生效以上只是在一个终端会话中临时设置的，如果要运用到所有的会话中，则需要在.bash_profile中写入：
1export JAVA_HOME=`/usr/libexec/java_home -v &#x27;1.6*&#x27;`

然后运行
1source ~/.bash_profile

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/jdk/" rel="tag">jdk</a>, <a class="tag-none-link" href="../../tags/mac/" rel="tag">mac</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/18/2013-11-18-vim-encoding-convert/">VIM对于文件字符编码的转换</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-18</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/18/2013-11-18-vim-encoding-convert/">
                    <p>
                        
                            使用vim自己的方式fenc, enc在Vim中输入:set fenc=编码  即可将文档的编码转换为相应的编码格式,这是只需要保存文档,文档的编码就变了。
如果在Vim中输入:set enc=编码  即可改变Vim的显示编码,这是就可以看到文档中的乱码了,不过这是即使对文档做了修改并保存,文档仍旧以之前的文档编码保存。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/linux/" rel="tag">linux</a>, <a class="tag-none-link" href="../../tags/mac/" rel="tag">mac</a>, <a class="tag-none-link" href="../../tags/vim/" rel="tag">vim</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2019/08/01/2013-08-01-macvim-config/">macvim配置</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2019-08-01</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2019/08/01/2013-08-01-macvim-config/">
                    <p>
                        
                            虽然我还没用，但是记下总是好的吧，这种东西网站一输如就能找到，就不放到笔记里了。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/it/" rel="tag">it</a>, <a class="tag-none-link" href="../../tags/macvim/" rel="tag">macvim</a>, <a class="tag-none-link" href="../../tags/vim/" rel="tag">vim</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2019/02/20/2013-02-20-vmware-network-config/">新手VMware网络配置</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2019-02-20</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2019/02/20/2013-02-20-vmware-network-config/">
                    <p>
                        
                            这个问题以前一直没专门去想过，只是网络不通了我才去折腾，实在不行就问别人，今天总算好好的去理解了一下。这篇文章能写出来，最需要感谢的是华叔。
首先，是对三种模式的理解：1.Bridged（桥接模式）:
主机&lt;–&gt;主机所在网段&lt;–&gt;虚拟机


比如：主机的IP为__192.168.40.230__，也就是__40网段__，那么虚拟机配__192.168.40.26__就可以和主机所在的网段通信，桥接的意思可以理解为主机的网卡直接插在虚拟机上。

2.Host-only:
主机和虚拟机之间建立自己的通信，需配置成网络在同一网段,两个虚拟机之间配置成Host-only也可以互相通信。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/IT/" rel="tag">IT</a>, <a class="tag-none-link" href="../../tags/VMware/" rel="tag">VMware</a>, <a class="tag-none-link" href="../../tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2018/04/05/2014-04-05-shortcuts-of-eclipse-on-mac/">Mac下Eclipse快捷键</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2018-04-05</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2018/04/05/2014-04-05-shortcuts-of-eclipse-on-mac/">
                    <p>
                        
                            实在是记不住，虽然windows下的和mac下的差不多，但是还是有那么点区别。
12345678910111213141516171819202122232425262728293031323334Command + O：显示大纲Command + 1：快速修复Command + D：删除当前行Command + Option + ↓：复制当前行到下一行Command + Option + ↑：复制当前行到上一行Option + ↓：当前行和下面一行交互位置Option + ↑：当前行和上面一行交互位置Option + ←：前一个编辑的页面Option + →：下一个编辑的页面Option + Return：显示当前选择资源的属性Shift + Return：在当前行的下一行插入空行Shift + Control + Return：在当前行插入空行Control + Q：定位到最后编辑的地方Control + M：最大化当前的Edit或View（再按则最小化）Control + &#x2F;：注释当前行，再按则取消注释Command + T：快速显示当前类的继承结构Command + W：关闭当前EditerCommand + K：参照当前选中的Word快速定位到下一个Command + E：快速显示当前Editer的下拉列表（如果当前页面没有显示的用黑体表示）Option + &#x2F;：代码助手完成一些代码的插入（俗称“智能提示”）Command + Shift + E：显示管理当前打开的所有的View的管理器Command + J：正向增量查找（按下Command + J后，你所输入的每个字母编辑器都提供快速匹配定位到某个单词，如果没有，则在Stutes Line中显示没有找到了）Command + Shift + J：反向增量查找Command + Shift + W：关闭所有打开的EditerCommand + Shift + X：把当前选中的文本全部变为大写Command + Shift + Y：把当前选中的文本全部变为小写Command + Shift + F：格式化当前代码Command + Shift + P：定位到对于的匹配符（譬如&#123;&#125;）（从前面定位后面时，光标要在匹配符里面，后面到前面，则反之）Option + Command + R：重命名（尤其是变量和类的Rename效果比较明显）Option + Shift + M：抽取方法（这是重构里面最常用的方法之一了，尤其是对一大堆泥团代码有用）Option + Command + C：修改函数结构（有N个函数调用了这个方法，修改一次就搞定）Option + Command + L：抽取本地变量（可以直接把一些魔法数字和字符串抽取成一个变量，尤其是多处调用的时候）Option + Shift + F：把Class中的Local变量变为Field变量（比较实用的功能）Option + Command + Z：重构的后悔药（Undo）
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/eclipse/" rel="tag">eclipse</a>, <a class="tag-none-link" href="../../tags/mac/" rel="tag">mac</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2018/04/04/2016-04-04-webjars-introduction/">WebJars介绍</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2018-04-04</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2018/04/04/2016-04-04-webjars-introduction/">
                    <p>
                        
                            什么是WebJars什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。
为什么使用WebJars我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理。
三种风格的WebJars官方提供三种风格的WebJars，NPM，Bower，和Classic。
NPM WebJars
根据镜像即时创建和部署
任何人都可以请求发布资源包
使用NPM的镜像资源，NPM是javascript（主要是nodejs，iojs）的包管理工具

Bower WebJars
根据镜像即时创建和部署
任何人都可以请求发布资源包
使用Bower的镜像资源，Bower是前端资源的管理工具

Classic WebJars
手工打包并且部署
只由WebJars官方团队发布
人工创建RequireJS配置文件（RequireJS是一个使浏览器使用javascript模块化的库）

前两种主要是使用很成熟的前端资源管理工具的仓库资源来创建jar包并且部署，但是任何人都可以发布包，这就造成了有些包的内容不严谨，说不定给你弄点恶意代码你都不知道，而第三种是由官方团队进行发布。
前两种根据镜像即时发布，可以使资源版本维持在最新状态，而第三种是手工打包的，难免会有延迟。
官方网站http://www.webjars.org/
关于WebJars的使用，可看我这篇WebJars使用示例

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">计算机常识</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/css/" rel="tag">css</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/javascript/" rel="tag">javascript</a>, <a class="tag-none-link" href="../../tags/webjars/" rel="tag">webjars</a>
                    
                </div>
            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            博落回
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归 —— 忆江南</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="../../2021/05/04/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%9A%84%E6%83%8A%E5%96%9C/">小红书的惊喜</a></li>
            
        
            
                <li><a href="../../2021/05/03/%E2%80%9C%E5%8D%97%E4%BA%AC%E5%8F%8B%E8%AE%B0-%E6%9D%8E%E5%AE%B6%E9%A6%A8%E2%80%9D/">南京友记-李家馨</a></li>
            
        
            
                <li><a href="../../2021/05/01/%E5%8D%97%E4%BA%AC%E4%B9%8B%E6%97%85-episode-1/">南京之旅-中山陵</a></li>
            
        
            
                <li><a href="../../2021/04/24/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E2%80%9D/">“计算机文件系统”</a></li>
            
        
            
                <li><a href="../../2021/04/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%93/">线性代数第二章总结</a></li>
            
        
            
                <li><a href="../../2021/04/23/2020%E8%80%83%E7%A0%94%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88408%EF%BC%89%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">2020考研计算机（408）考试大纲</a></li>
            
        
            
                <li><a href="../../2021/04/22/%E2%80%9C%E5%B9%82%E7%BA%A7%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%9D/">“幂级数的本质”</a></li>
            
        
            
                <li><a href="../../2021/04/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/">线性代数第一章节总结</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../hexo/">hexo</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="../java/">java</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="../mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../ui/">ui</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../%E4%B8%89%E5%89%91%E5%AE%A2/">三剑客</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../%E7%94%9F%E6%B4%BB/">生活</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="">计算机常识</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88/">计算机网络综合</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/">高等数学</a><span class="category-list-count">7</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/05/">2021-05</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/04/">2021-04</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/03/">2021-03</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/02/">2021-02</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/01/">2021-01</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/12/">2020-12</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/11/">2020-11</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/10/">2020-10</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/09/">2020-09</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/08/">2020-08</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/07/">2020-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/06/">2020-06</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/03/">2020-03</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/02/">2020-02</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/12/">2019-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/10/">2019-10</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/08/">2019-08</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/07/">2019-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/06/">2019-06</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/05/">2019-05</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/03/">2019-03</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/02/">2019-02</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/12/">2018-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/11/">2018-11</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/05/">2018-05</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/04/">2018-04</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/03/">2018-03</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2016/04/">2016-04</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2015/04/">2015-04</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2013/06/">2013-06</a><span class="archive-list-count">1</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="../../tags/CSS/" style="font-size: 11.11px;">CSS</a> <a href="../../tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="../../tags/Field/" style="font-size: 10px;">Field</a> <a href="../../tags/Groovy/" style="font-size: 10px;">Groovy</a> <a href="../../tags/HTML/" style="font-size: 11.11px;">HTML</a> <a href="../../tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="../../tags/IDE/" style="font-size: 11.11px;">IDE</a> <a href="../../tags/IT/" style="font-size: 17.78px;">IT</a> <a href="../../tags/JAVA/" style="font-size: 12.22px;">JAVA</a> <a href="../../tags/JVM/" style="font-size: 10px;">JVM</a> <a href="../../tags/Java/" style="font-size: 14.44px;">Java</a> <a href="../../tags/JavaScript/" style="font-size: 11.11px;">JavaScript</a> <a href="../../tags/MYSQL/" style="font-size: 10px;">MYSQL</a> <a href="../../tags/Maven/" style="font-size: 10px;">Maven</a> <a href="../../tags/NoSql/" style="font-size: 10px;">NoSql</a> <a href="../../tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="../../tags/Python/" style="font-size: 10px;">Python</a> <a href="../../tags/TOMCAT/" style="font-size: 10px;">TOMCAT</a> <a href="../../tags/UI/" style="font-size: 10px;">UI</a> <a href="../../tags/VMware/" style="font-size: 10px;">VMware</a> <a href="../../tags/Wicket/" style="font-size: 10px;">Wicket</a> <a href="../../tags/coding/" style="font-size: 10px;">coding</a> <a href="../../tags/coding-net/" style="font-size: 12.22px;">coding.net</a> <a href="../../tags/css/" style="font-size: 13.33px;">css</a> <a href="../../tags/date/" style="font-size: 10px;">date</a> <a href="../../tags/debug/" style="font-size: 10px;">debug</a> <a href="../../tags/decorator/" style="font-size: 10px;">decorator</a> <a href="../../tags/eclipse/" style="font-size: 10px;">eclipse</a> <a href="../../tags/editor/" style="font-size: 10px;">editor</a> <a href="../../tags/equals/" style="font-size: 10px;">equals</a> <a href="../../tags/express/" style="font-size: 10px;">express</a> <a href="../../tags/git/" style="font-size: 10px;">git</a> <a href="../../tags/github/" style="font-size: 12.22px;">github</a> <a href="../../tags/gogs/" style="font-size: 10px;">gogs</a> <a href="../../tags/hexo/" style="font-size: 16.67px;">hexo</a> <a href="../../tags/https/" style="font-size: 10px;">https</a> <a href="../../tags/i18n/" style="font-size: 10px;">i18n</a> <a href="../../tags/ini/" style="font-size: 10px;">ini</a> <a href="../../tags/it/" style="font-size: 15.56px;">it</a> <a href="../../tags/jar/" style="font-size: 10px;">jar</a> <a href="../../tags/java/" style="font-size: 20px;">java</a> <a href="../../tags/javascript/" style="font-size: 12.22px;">javascript</a> <a href="../../tags/jdk/" style="font-size: 10px;">jdk</a> <a href="../../tags/jvm/" style="font-size: 10px;">jvm</a> <a href="../../tags/less/" style="font-size: 10px;">less</a> <a href="../../tags/linux/" style="font-size: 11.11px;">linux</a> <a href="../../tags/mac/" style="font-size: 12.22px;">mac</a> <a href="../../tags/macvim/" style="font-size: 10px;">macvim</a> <a href="../../tags/markdown/" style="font-size: 10px;">markdown</a> <a href="../../tags/maven/" style="font-size: 11.11px;">maven</a> <a href="../../tags/mediator/" style="font-size: 10px;">mediator</a> <a href="../../tags/nginx/" style="font-size: 10px;">nginx</a> <a href="../../tags/object/" style="font-size: 10px;">object</a> <a href="../../tags/observer/" style="font-size: 10px;">observer</a> <a href="../../tags/qcloud/" style="font-size: 10px;">qcloud</a> <a href="../../tags/rails/" style="font-size: 10px;">rails</a> <a href="../../tags/reflect/" style="font-size: 10px;">reflect</a> <a href="../../tags/remote/" style="font-size: 10px;">remote</a> <a href="../../tags/ssh/" style="font-size: 10px;">ssh</a> <a href="../../tags/ssl/" style="font-size: 10px;">ssl</a> <a href="../../tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="../../tags/travis/" style="font-size: 12.22px;">travis</a> <a href="../../tags/vim/" style="font-size: 11.11px;">vim</a> <a href="../../tags/web/" style="font-size: 11.11px;">web</a> <a href="../../tags/webjars/" style="font-size: 11.11px;">webjars</a> <a href="../../tags/wicket/" style="font-size: 11.11px;">wicket</a> <a href="../../tags/%E4%B8%AD%E4%BB%8B%E8%80%85/" style="font-size: 10px;">中介者</a> <a href="../../tags/%E5%81%87%E6%9C%9F/" style="font-size: 10px;">假期</a> <a href="../../tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="../../tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.11px;">前端</a> <a href="../../tags/%E5%91%A8%E6%9C%AB/" style="font-size: 11.11px;">周末</a> <a href="../../tags/%E5%9B%BE%E7%89%87/" style="font-size: 11.11px;">图片</a> <a href="../../tags/%E5%A5%BD%E6%96%87/" style="font-size: 10px;">好文</a> <a href="../../tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 10px;">小知识点</a> <a href="../../tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 10px;">工作</a> <a href="../../tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="../../tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a> <a href="../../tags/%E5%BF%83%E6%83%85/" style="font-size: 10px;">心情</a> <a href="../../tags/%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">技术</a> <a href="../../tags/%E6%95%99%E7%A8%8B/" style="font-size: 10px;">教程</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84/" style="font-size: 10px;">数据机构</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="../../tags/%E6%96%87%E7%AB%A0/" style="font-size: 10px;">文章</a> <a href="../../tags/%E6%97%A0%E5%9B%BE/" style="font-size: 10px;">无图</a> <a href="../../tags/%E6%97%A5%E5%BF%97/" style="font-size: 18.89px;">日志</a> <a href="../../tags/%E6%97%A5%E8%AE%B0/" style="font-size: 10px;">日记</a> <a href="../../tags/%E6%9D%82%E4%BA%8B/" style="font-size: 16.67px;">杂事</a> <a href="../../tags/%E6%9D%82%E6%96%87/" style="font-size: 10px;">杂文</a> <a href="../../tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="../../tags/%E6%B2%B9%E6%BC%86%E5%B7%A5/" style="font-size: 10px;">油漆工</a> <a href="../../tags/%E7%94%9F%E6%B4%BB/" style="font-size: 11.11px;">生活</a> <a href="../../tags/%E7%94%B5%E5%BD%B1/" style="font-size: 10px;">电影</a> <a href="../../tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 10px;">线性代数</a> <a href="../../tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="../../tags/%E8%88%B6%E6%9D%A5%E5%93%81/" style="font-size: 10px;">舶来品</a> <a href="../../tags/%E8%89%BA%E6%9C%AF%E5%AE%B6/" style="font-size: 10px;">艺术家</a> <a href="../../tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">虚拟机</a> <a href="../../tags/%E8%A7%82%E5%AF%9F%E8%80%85/" style="font-size: 10px;">观察者</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 14.44px;">计算机</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86/" style="font-size: 10px;">计算机常识</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 14.44px;">计算机网络</a> <a href="../../tags/%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">记录</a> <a href="../../tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.44px;">设计模式</a> <a href="../../tags/%E8%AF%B4%E7%82%B9%E5%95%A5/" style="font-size: 10px;">说点啥</a> <a href="../../tags/%E8%BF%90%E5%8A%A8/" style="font-size: 10px;">运动</a> <a href="../../tags/%E9%A3%8E%E6%99%AF/" style="font-size: 10px;">风景</a> <a href="../../tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 14.44px;">高等数学</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>