<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content="java leetcode mysql hexo"/>



    <meta name="description" content="雨争齐齐齐"/>


<meta name="Robots" content="all">


    <title>齐雨争</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="../../css/font-awesome.min.css">


<link rel="stylesheet" href="../../css/atom-one-dark.css">


<link rel="stylesheet" href="../../css/style.css">


<script src="../../js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >Home</a>
            
                <a class="nav-item" href="/resume"
                
                >Resume</a>
            
                <a class="nav-item" href="/mood"
                
                   target="_blank"
                
                >Mood</a>
            
                <a class="nav-item" href="/amusement/tetris"
                
                   target="_blank"
                
                >Amusement</a>
            
                <a class="nav-item" href="/about"
                
                >About</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/18/qcloud-nginx-ssl/">Nginx使用SSL证书配置https</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-18</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/18/qcloud-nginx-ssl/">
                    <p>
                        
                            申请SSL证书首先申请SSL证书，这里以腾讯云的免费DVSSL证书为例，前往 https://console.cloud.tencent.com/ssl/apply

填入通用名称，比如 www.wxio.club
最好不要密码
填好其他信息
点击下一步，如果域名在腾讯云解析，就选择 自动DNS验证，否则按照选项进行配置
点击确认申请

下载和上传证书前往 https://console.cloud.tencent.com/ssl 下载刚申请的证书，以 www.wxio.club 为例，解压后有
12345678910111213141516.├── Apache│   ├── 1_root_bundle.crt│   ├── 2_www.wxio.club.crt│   └── 3_www.wxio.club.key├── IIS│   ├── keystorePass.txt│   └── www.wxio.club.pfx├── Nginx│   ├── 1_www.wxio.club_bundle.crt│   └── 2_www.wxio.club.key├── Tomcat│   ├── keystorePass.txt│   └── www.wxio.club.jks└── www.wxio.club.csr

复制Nginx里的 1_www.wxio.club_bundle.crt 和 2_www.wxio.club.key 到服务器的 /etc/nginx （其实那都可以）
配置 nginx.conf编辑器打开 /etc/nginx/nginx.conf, 在 http 下面，添加或者修改配置：
123456789101112131415161718192021222324server &#123;        listen 80;        server_name www.wxio.club wxio.club;        rewrite ^(.*)$ https:&#x2F;&#x2F;$&#123;server_name&#125;$1 permanent; # 这里是使 http 跳转到 https&#125;server &#123;        listen 443;        server_name www.wxio.club wxio.club;        ssl on;        ssl_certificate 1_www.wxio.club_bundle.crt; # 这里可以写 .crt 的全路径        ssl_certificate_key 2_www.wxio.club.key; # 这里可以写 .key 的全路径        ssl_session_timeout 5m;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;        ssl_prefer_server_ciphers on;        location &#x2F; &#123;                root &#x2F;home&#x2F;git&#x2F;www&#x2F;public;                index index.html index.htm;        &#125;&#125;

重启 nginx 服务1service nginx restart

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/https/" rel="tag">https</a>, <a class="tag-none-link" href="../../tags/nginx/" rel="tag">nginx</a>, <a class="tag-none-link" href="../../tags/qcloud/" rel="tag">qcloud</a>, <a class="tag-none-link" href="../../tags/ssl/" rel="tag">ssl</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/15/port%E8%AE%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">论数据库连接池</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-15</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/15/port%E8%AE%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/">
                    <p>
                        
                            数据库连接是一种关键的有限的昂贵的资源，这一点企业级应用程序中体现得尤为突出。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正是针对这个问题提出来的。
  数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而再不是重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。
具体工作机制如下：
数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。
数据库连接池的最小连接数和最大连接数的设置要考虑到下列几个因素：

最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费；

最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。

如果最小连接数与最大连接数相差太大，那么最先的连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用完不会马上被释放，它将被放到连接池中等待重复使用或是空闲超时后被释放。


===================================================================
J2EE服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。
  调用：客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为 忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。
释放：当使用的池连接调用完成后，池驱动程序将此连接表记为空闲， 其他调用就可以使用这个连接。
最大维持连接数：没有任何请求时在连接池中可以存在的连接数
最大连接数：连接池中最多可以存在的连接个数。
最大等待时间：当断开连接时，超过最大维持连接数的连接不会马上销毁，最大等待时间过后它才会销毁。
连接池是将已经创建好的连接保存在池中，当有请求来时，直接使用已经创建好的连接对数据库进行访问。这样省略了创建连接和销毁连接的过程。
现在假设：最大维持连接数是10，最大连接数是20，最大等待时间是10000（毫秒）
其过程：最开始在连接池中有10个连接（最大连接数），当有用户申请连接时，其将一个连接分配用户，直到连接池中的10个连接全都分配出去，当第11个用户申请连接时，它将创建第11个连接并分配给该用户，直到把第20个连接（最大连接数）分配给第20个用户，当第21个用户申请连接时，它需要等待，直到前面的20个用户中某一个断开了连接，才会把那个连接分配给第21个用户，当用户断开连接时（第11至20个连接），该连接不会立刻被释放而是需要等待10000毫秒（最大等待时间），才被释放，当没有用户连接时，连接池内还保持10个连接。
在开发中，使用连接池时若没有关闭连接（调用连接的close方法）会出现“连接池疲劳的错误”。
数据连接池的主要作用是什么?
数据连接池是把数据库连接放到中间服务器上,比如tomcat上,那么相当于每次你操作数据库的时候就不需要再”连接”到数据库再进行相关操作,而是直接操作服务器上的”连接池”,你可以根据字面意思进行理解,把数据库当做一条小溪,那么”连接池”就是一个”水池”,这个水池里面的水是由事先架好的通向”小溪”的水管引进来的,所以,你想喝水的时候不必大老远地跑到小溪边上,而只要到这个水池就可以.这样的话就可以提高”效率”.但是数据池一般是用在数据量比较大的项目,这样可以提高程序的效率,想一想这样的话是不是就把相关的负荷加在了服务器上,因为这个”池”是在服务器上的,对于小数据量处理的项目不推荐使用,应为过于频繁的请求会使得服务器负载加重
关系:
 你 –&gt;”水池”–&gt;小溪(快速喝水)
 程序–&gt;”数据池”–&gt;数据库(快速存取)
就是这样,也不用把它想神秘了,我是这样理解的,也就这样说了,希望对你有帮助
数据连接池怎么设置？
在数据库连接字段的时候可以设置
比如：“DataSource=Server;Initial;Catalog=db;UserID=test;Password=test;
 MaxPoolSize = 100;MinPoolSize= 15”
这样 连接池 最大为100，最小为15

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" rel="tag">计算机</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/04/08/2013-05-08-ui-design-principles/">好文用户接口（UI）设计的 20 条原则</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-08</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/04/08/2013-05-08-ui-design-principles/">
                    <p>
                        
                            
世界级图形设计大师Paul Rand（保罗.兰德）曾经说过：“设计绝不是简单的排列组合与简单地再编辑，它应当充满着价值和意义，去说明道理，去删繁就简，去阐明演绎，去修饰美 化，去赞美褒扬，使其有戏剧意味，让人们信服你所言……”，由此可见，设计绝非轻而易举之事，优秀的设计更是难上加难，今日小编偶然发现一篇界面设计师 Joshua Porter博客当中的一篇文章——《Principles of User Interface Design》，文章中列举了20大UI设计原则，看完之后，觉得挺受启发，于是试着将其编译，希望能够给广大设计师——特别是刚入门的初级设计师，提供 较好的学习机会。全文编译如下：
1.清晰度是首要工作清晰度是界面设计中，第一步也是最重要的工作。要想你设计的界面有效并被人喜欢，首先必须让用户能够识别出它？让用户知道为什么会使用它？比如当用户使用 时，能够预料到发生什么，并成功的与它交互。有的界面设计得不是太清晰，虽然能够满足用户一时的需求，但并非长久之计，而清晰的界面能够吸引用户不断地重 复使用。
2.界面是为促进交互而存在的界面的存在，促进了用户和我们的世界之间的互动。优秀的界面不但能够让我们做事有效率，还能够激发、唤起和加强我们与这个世界的联系。
3.保护和尊重用户的注意力我们在阅读的时候，总是会有许多事物分散我们的注意力，使得我们很难集中注意力安静地阅读。因此，在进行界面设计的时候，能够吸引用户的注意力是很关键 的，所以千万不要将你应用的周围设计得乱七八糟分散人的注意力，谨记屏幕整洁能够吸引注意力的重要性。如果你非要显示广告，那么请在用户阅读完毕之后再显 示。尊重用户的注意力，不仅让用户更快乐，而且你的广告效果也会更佳。因此要想设计好的界面，保护和尊重用户的注意力是先决条件。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E5%A5%BD%E6%96%87/" rel="tag">好文</a>, <a class="tag-none-link" href="../../tags/%E6%96%87%E7%AB%A0/" rel="tag">文章</a>, <a class="tag-none-link" href="../../tags/%E8%88%B6%E6%9D%A5%E5%93%81/" rel="tag">舶来品</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/03/26/2016-03-26-distributed-data-model/">数据分布式模型</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-03-26</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/03/26/2016-03-26-distributed-data-model/">
                    <p>
                        
                            概述数据的分布有两种途径：

复制（replication）：
  将同一份数据拷贝至多个节点；复制又分为：主从式（master-slave）和对等式（peer-to-peer）。

分片（sharding）：
  将不同数据存放在不同节点。


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/NoSql/" rel="tag">NoSql</a>, <a class="tag-none-link" href="../../tags/it/" rel="tag">it</a>, <a class="tag-none-link" href="../../tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/03/09/2016-03-09-java-memory-area-structure/">Java运行时内存结构</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-03-09</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/03/09/2016-03-09-java-memory-area-structure/">
                    <p>
                        
                            
由图所示，Java运行时内存区域分为：虚拟机栈、方法区、本地方法栈、程序计数器和堆。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/it/" rel="tag">it</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/jvm/" rel="tag">jvm</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2021/01/30/2015-01-30-diffrence-between-mvn-clean-install-and-mvn-install/">mvn打包的时候为什么用clean</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-01-30</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2021/01/30/2015-01-30-diffrence-between-mvn-clean-install-and-mvn-install/">
                    <p>
                        
                            
   理论上来讲不做mvn clean 得到的jar包应该是最新的，除非其他方式修改jar包中的内容而不修改源代码。

   平时可以用mvn install，而不进行chean节省时间（如果你觉得节省时间多的话），但最保险还是用 mvn clean install 生成最新的jar包或其他包

   不想用mvn clean又想保证jar包最新，建议添加 -Djar.forceCreation 参数



                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/maven/" rel="tag">maven</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/12/10/docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/">Docker环境下使用mysql数据库</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-12-10</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/12/10/docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8mysql%E6%95%B0%E6%8D%AE%E5%BA%93/">
                    <p>
                        
                            使用Docker搭建MySQL服务一、安装docker#windows 和 mac 版可以直接到官网下载 docker desktop
linux 的安装方法可以参考 https://www.cnblogs.com/myzony/p/9071210.html
可以在shell中输入以下命令检查是否成功安装： sudo docker version
二、建立镜像#
拉取官方镜像（我们这里选择5.7，如果不写后面的版本号则会自动拉取最新版）
12Copydocker pull mysql:5.7   # 拉取 mysql 5.7docker pull mysql       # 拉取最新版mysql镜像

MySQL文档地址

检查是否拉取成功
1Copy$ sudo docker images
一般来说数据库容器不需要建立目录映射
1Copysudo docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7


–name：容器名，此处命名为mysql
-e：配置信息，此处配置mysql的root用户的登陆密码
-p：端口映射，此处映射 主机3306端口 到 容器的3306端口


如果要建立目录映射
123456Copyduso docker run -p 3306:3306 --name mysql \-v /usr/local/docker/mysql/conf:/etc/mysql \-v /usr/local/docker/mysql/logs:/var/log/mysql \-v /usr/local/docker/mysql/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql:5.7


-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录


检查容器是否正确运行
1Copydocker container ls


可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字



三、连接mysql#
进入docker本地连接mysql客户端
12Copysudo docker exec -it mysql bashmysql -uroot -p123456
使用 Navicat 远程连接mysql
我只找到了 mac 版本的 Navicat Premiun（如下），没有找到windows和linux的。大家可以自行寻找。
 百度云连接 密码: qps3 （该软件包来自著名分享网站 Pirate ，并感谢网友 chaosgod 和 jor_ivy）


安装完之后：复制中文包”zh-Hans.lproj”放到 /Contents/Resources 即可。（应用程序右键显示包内容）

使用远程连接软件时要注意一个问题
我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问：
1234Copyhost: 127.0.0.1port: 3306user: rootpassword: 123456
如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：

防火墙阻拦
123456Copy# 开放端口：$ systemctl status firewalld$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent$ firewall-cmd  --reload# 关闭防火墙：$ sudo systemctl stop firewalld
需要进入docker本地客户端设置远程访问账号
123Copy$ sudo docker exec -it mysql bash$ mysql -uroot -p123456mysql&gt; grant all privileges on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;

原理：
1234567891011121314151617181920212223242526272829Copy# mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）mysql&gt; use mysql;Database changedmysql&gt; select host,user,password from user;+--------------+------+-------------------------------------------+| host                    | user      | password                                                                 |+--------------+------+-------------------------------------------+| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      || 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |+--------------+------+-------------------------------------------+2 rows in set (0.00 sec)mysql&gt; grant all privileges  on *.* to root@&#x27;%&#x27; identified by &quot;password&quot;;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)mysql&gt; select host,user,password from user;+--------------+------+-------------------------------------------+| host                    | user      | password                                                                 |+--------------+------+-------------------------------------------+| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     || 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     || %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |+--------------+------+-------------------------------------------+3 rows in set (0.00 sec)



参考连接：#https://blog.csdn.net/jor_ivy/article/details/81323199
https://www.52pojie.cn/thread-727433-1-1.html

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/12/07/%E7%AE%80%E8%BF%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/">简述微服务设计</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-12-07</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/12/07/%E7%AE%80%E8%BF%B0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/">
                    <p>
                        
                            一文详解微服务架构本文将介绍微服务架构和相关的组件，介绍他们是什么以及为什么要使用微服务架构和这些组件。本文侧重于简明地表达微服务架构的全局图景，因此不会涉及具体如何使用组件等细节。要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。本文将以一个网上超市应用为例来说明这一过程。最初的需求几年前，小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。我们整理一下功能清单：网站：用户注册、登录功能商品展示下单管理后台：用户管理商品管理订单管理由于需求简单，小明左手右手一个慢动作，网站就做好了。管理后台出于安全考虑，不和网站做在一起，小明右手左手慢动作重播，管理网站也做好了。总体架构图如下：
小明挥一挥手，找了家云服务部署上去，网站就上线了。上线后好评如潮，深受各类肥宅喜爱。小明小皮美滋滋地开始躺着收钱。随着业务发展……好景不长，没过几天，各类网上超市紧跟着拔地而起，对小明小皮造成了强烈的冲击。在竞争的压力下，小明小皮决定开展一些营销手段：开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。精准营销。利用历史数据对用户进行分析，提供个性化服务。……这些活动都需要程序开发的支持。小明拉了同学小红加入团队。小红负责数据分析以及移动端相关开发。小明负责促销活动相关功能的开发。因为开发任务比较紧迫，小明小红没有好好规划整个系统的架构，随便拍了拍脑袋，决定把促销管理和数据分析放在管理后台里，微信和移动端APP另外搭建。通宵了几天后，新功能和新应用基本完工。这时架构图如下：这一阶段存在很多不合理的地方：网站和移动端应用有很多相同业务逻辑的重复代码。数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。数据库表结构被多个应用依赖，无法重构和优化。所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。为了减轻发布可能产生的问题的影响和线上业务停顿的影响，所有应用都要在凌晨三四点执行发布。发布后为了验证应用正常运行，还得盯到第二天白天的用户高峰期……团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。尽管有着诸多问题，但也不能否认这一阶段的成果：快速地根据业务变化建设了系统。不过紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策。在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。是时候做出改变了幸好小明和小红是有追求有理想的好青年。意识到问题后，小明和小红从琐碎的业务需求中腾出了一部分精力，开始梳理整体架构，针对问题准备着手改造。要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以致于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……在编程的世界中，最重要的便是抽象能力。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：用户服务商品服务促销服务订单服务数据分析服务各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：这个阶段只是将服务分开了，数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：数据库成为性能瓶颈，并且有单点故障的风险。数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。改造完成后，小明和小红分清楚各自的锅。两人十分满意，一切就像是麦克斯韦方程组一样漂亮完美。然而……没有银弹春天来了，万物复苏，又到了一年一度的购物狂欢节。眼看着日订单数量蹭蹭地上涨，小皮小明小红喜笑颜开。可惜好景不长，乐极生悲，突然嘣的一下，系统挂了。以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而微服务架构整个应用分散成多个服务，定位故障点非常困难。小明一个台机器一台机器地查看日志，一个服务一个服务地手工调用。经过十几分钟的查找，小明终于定位到故障点：促销服务由于接收的请求量太大而停止响应了。其他服务都直接或间接地会调用促销服务，于是也跟着宕机了。在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障。其实在节前，小明和小红是有做过请求量评估的。按照预计，服务器资源是足以支持节日的请求量的，所以肯定是哪里出了问题。不过形势紧急，随着每一分每一秒流逝的都是白花花的银子，因此小明也没时间排查问题，当机立断在云上新建了几台虚拟机，然后一台一台地部署新的促销服务节点。几分钟的操作后，系统总算是勉强恢复正常了。整个故障时间内估计损失了几十万的销售额，三人的心在滴血……事后，小明简单写了个日志分析工具（量太大了，文本编辑器几乎打不开，打开了肉眼也看不过来），统计了促销服务的访问日志，发现在故障期间，商品服务由于代码问题，在某些场景下会对促销服务发起大量请求。这个问题并不复杂，小明手指抖一抖，修复了这个价值几十万的Bug。问题是解决了，但谁也无法保证不会再发生类似的其他问题。微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：微服务架构整个应用分散成多个服务，定位故障点非常困难。稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。服务数量非常多，部署、管理的工作量很大。开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。小明小红痛定思痛，决心好好解决这些问题。对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。监控 - 发现故障的征兆在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。微服务架构中组件繁多，各个组件所需要监控的指标不同。比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。大部分组件都不需要自己动手开发，网络上有开源组件。小明下载了RedisExporter和MySQLExporter，这两个组件分别提供了Redis缓存和MySQL数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的指标接口。然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：定位问题 - 链路跟踪在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。我们用一个Istio文档里的链路跟踪例子来看看效果：图片来自Istio文档从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。spanId：标识一次服务调用的ID，即链路跟踪的节点ID。parentId：父节点的spanId。requestTime &amp; responseTime：请求时间和响应时间。另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。以上只是一个极简的说明，关于链路跟踪的理论依据可详见Google的Dapper了解了理论基础后，小明选用了Dapper的一个开源实现Zipkin。然后手指一抖，写了个HTTP请求的拦截器，在每次HTTP请求时生成这些数据注入到HEADERS，同时异步发送调用日志到Zipkin的日志收集器中。这里额外提一下，HTTP请求的拦截器，可以在微服务的代码中实现，也可以使用一个网络代理组件来实现（不过这样子每个微服务都需要加一层代理）。链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。分析问题 - 日志分析日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：小明调查了一下，使用了大名鼎鼎地ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。Elasticsearch：搜索引擎，同时也是日志的存储。Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。最后还有一个小问题是如何将日志发送到Logstash。一种方案是在日志输出的时候直接调用Logstash接口将日志发送过去。这样一来又（咦，为啥要用“又”）要修改代码……于是小明选用了另一种方案：日志仍然输出到文件，每个服务里再部署个Agent扫描日志文件然后输出给Logstash。网关 - 权限控制，服务治理拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。由于整个网上超市的服务数量还不算特别多，小明采用的最粗粒度的方案：服务注册于发现 - 动态扩容前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。冗余的一个问题是使用几个冗余？这个问题在时间轴上并没有一个切确的答案。根据服务功能、时间段的不同，需要不同数量的实例。比如在平日里，可能4个实例已经够用；而在促销活动时，流量大增，可能需要40个实例。因此冗余数量并不是一个固定的值，而是根据需要实时调整的。一般来说新增实例的操作为：部署新实例将新实例注册到负载均衡或DNS上操作只有两步，但如果注册到负载均衡或DNS的操作为人工操作的话，那事情就不简单了。想想新增40个实例后，要手工输入40个IP的感觉……解决这个问题的方案是服务自动注册与发现。首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……熔断、服务降级、限流熔断当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。图片来自《微服务设计》服务降级当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。限流一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。测试微服务架构下，测试分为三个层次：端到端测试：覆盖整个系统，一般在用户界面机型测试。服务测试：针对服务接口进行测试。单元测试：针对代码单元进行测试。三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。由于端到端测试实施难度较大，一般只对核心功能做端到端测试。一旦端到端测试失败，则需要将其分解到单元测试：则分析失败原因，然后编写单元测试来重现这个问题，这样未来我们便可以更快地捕获同样的错误。服务测试的难度在于服务会经常依赖一些其他服务。这个问题可以通过Mock Server解决：单元测试大家都很熟悉了。我们一般会编写大量的单元测试（包括回归测试）尽量覆盖所有代码。微服务框架指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。使用微服务框架可以实现很多自定义的功能。甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态。使用统一的微服务框架有一个比较严重的问题：框架更新成本很高。每次框架升级，都需要所有应用服务配合升级。当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级……因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范。另一条路 - Service Mesh*另一种抽象公共代码的方法是直接将这些代码抽象到一个反向代理组件。每个服务都额外部署这个代理组件，所有出站入站的流量都通过该组件进行处理和转发。这个组件被称为Sidecar。Sidecar不会产生额外网络成本。Sidecar会和微服务节点部署在同一台主机上并且共用相同的虚拟网卡。所以sidecar和微服务节点的通信实际上都只是通过内存拷贝实现的。**图片来自：Pattern: Service Mesh*Sidecar只负责网络通信。还需要有个组件来统一管理所有sidecar的配置。在Service Mesh中，负责网络通信的部分叫数据平面（data plane），负责配置管理的部分叫控制平面（control plane）。数据平面和控制平面构成了Service Mesh的基本架构。*图片来自：Pattern: Service Mesh*Sevice Mesh相比于微服务框架的优点在于它不侵入代码，升级和维护更方便。它经常被诟病的则是性能问题。即使回环网络不会产生实际的网络请求，但仍然有内存拷贝的额外成本。另外有一些集中式的流量处理也会影响性能。结束、也是开始微服务不是架构演变的终点。往细走还有Serverless、FaaS等方向。另一方面也有人在唱合久必分分久必合，重新发现单体架构……不管怎样，微服务架构的改造暂时告一段落了。小明满足地摸了摸日益光滑的脑袋，打算这个周末休息一下约小红喝杯咖啡。
微服务架构区别于传统的单体软件架构，是一种为了适应当前互联网后台服务的「三高需求：高并发、高性能、高可用」而产生的的软件架构。由于工作需要，本人曾调研过微服务相关内容，其实微服务也没什么神秘的，今天就用图解的形式了来和大家唠唠什么是微服务？****单体式应用程序与微服务相对的另一个概念是传统的单体式应用程序( Monolithic application )，单体式应用内部包含了所有需要的服务。而且各个服务功能模块有很强的耦合性，也就是相互依赖彼此，很难拆分和扩容。说在做的各位都写过单体程序，大家都没意见吧？给大家举个栗子，刚开始写代码你写的helloworld程序就是单体程序，一个程序包含所有功能，虽然 helloworld 功能很简单。单体应用程序的优点开发简洁，功能都在单个程序内部，便于软件设计和开发规划。容易部署，程序单一不存在分布式集群的复杂部署环境，降低了部署难度。容易测试，没有各种复杂的服务调用关系，都是内部调用方便测试。单体应用程序的缺点单体程序的缺点一开始不是特别明显，项目刚开始需求少，业务逻辑简单，写代码一时爽，一直爽。噩梦从业务迭代更新，系统日益庞大开始，前期的爽没有了，取而代之的是软件维护和迭代更新的无尽痛苦。由于单体式应用程序就像一个大型容器一样，里面放置了许多服务，且他们都是密不可分的，这导致应用程序在扩展时必须以「应用程序」为单位。当里面有个业务模块负载过高时，并不能够单独扩展该服务，必须扩展整个应用程序（就是这么霸道），这可能导致额外的资源浪费。此外，单体式应用程序由于服务之间的紧密度、相依性过高，这将导致测试、升级有所困难，且开发曲线有可能会在后期大幅度地上升，令开发不易。相较之下「微服务架构」能够解决这个问题。微服务微服务 (Microservices) 就是一些协同工作小而自治的服务。2014年，Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现 。「维基百科」举例还是拿前面的 helloworld 程序来举栗子，想象一下你是 helloworld 公司的 CTO（老板还缺人吗？会写代码的那种），假设你们公司的 helloworld 业务遍布全球，需要编写不同语种的 helloworld 版本，分别输出英语、日语、法语、俄语…现在世界有6000多种语言（奇怪的知识又增加了）。有人会说这还不简单我用switch case语句就完事了，同学，不要较真我就是举个例子，现实中的业务比 helloworld 复杂多了。好了，我们姑且认为按语言输出是个庞大复杂的工作，这时候就可以用微服务架构了，架构图如下：微服务与SOA****面向服务的体系结构 SOA (Service-Oriented Architecture) 听起来和微服务很像，但 SOA 早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间，最终 SOA 看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。 此外，实施SOA时会遇到很多问题，比如通信协议（例如SOAP)的选择、第三方中间件如何选择、服务粒度如何确定等，目前也存在一些关于如何划分系统的指导性原则，但其中有很多都是错误的。SOA并没有告诉你如何划分单体应用成微服务，所以在实施SOA时会遇到很多问题。这些问题再微服务框架中得到很好的解决，你可以认为微服务架构是SOA的一种特定方法。微服务架构合久必分，鉴于「单体应用程序」有上述的缺点，单个应用程序被划分成各种小的、互相连接的微服务，一个微服务完成一个比较单一的功能，相互之间保持独立和解耦合，这就是微服务架构。微服务优点相对于单体服务，微服务有很多优点，这里列举几个主要的好处技术异构性不同服务内部的开发技术可以不一致，你可以用java来开发helloworld服务A，用golang来开发helloworld服务B，大家再也不用为哪种语言是世界上最好的语言而争论不休。 为不同的服务选择最适合该服务的技术，系统中不同部分也可以使用不同的存储技术，比如A服务可以选择redis存储，B服务你可以选择用MySQL存储，这都是允许的，你的服务你做主。隔离性一个服务不可用不会导致另一个服务也瘫痪，因为各个服务是相互独立和自治的系统。这在单体应用程序中是做不到的，单体应用程序中某个模块瘫痪，必将导致整个系统不可用，当然，单体程序也可以在不同机器上部署同样的程序来实现备份，不过，同样存在上面说的资源浪费问题。可扩展性庞大的单体服务如果出现性能瓶颈只能对软件整体进行扩展，可能真正影响性能的只是其中一个很小的模块，我们也不得不付出升级整个应用的代价。这在微服务架构中得到了改善，你可以只对那些影响性能的服务做扩展升级，这样对症下药的效果是很好的。简化部署如果你的服务是一个超大的单体服务，有几百万行代码，即使修改了几行代码也要重新编译整个应用，这显然是非常繁琐的，而且软件变更带来的不确定性非常高，软件部署的影响也非常大。在微服务架构中，各个服务的部署是独立的，如果真出了问题也只是影响单个服务，可以快速回滚版本解决。易优化微服务架构中单个服务的代码量不会很大，这样当你需要重构或者优化这部分服务的时候，就会容易很多，毕竟，代码量越少意味着代码改动带来的影响越可控。微服务缺点我们上面一直在强调微服务的好处，但是，微服务架构不是万能的，并不能解决所有问题，其实这也是微服务把单体应用拆分成很多小的分布式服务导致的，所谓人多手杂，服务多起来管理的不好各种问题就来了。为了解决微服务的缺点，前辈们提出了下面这些概念。服务注册与发现微服务之间相互调用完成整体业务功能，如何在众多微服务中找到正确的目标服务地址，这就是所谓「服务发现」功能。常用的做法是服务提供方启动的时候把自己的地址上报给「服务注册中心」，这就是「服务注册」。服务调用方「订阅」服务变更「通知」，动态的接收服务注册中心推送的服务地址列表，以后想找哪个服务直接发给他就可以。服务监控单体程序的监控运维还好说，大型微服务架构的服务运维是一大挑战。服务运维人员需要实时的掌握服务运行中的各种状态，最好有个控制面板能看到服务的内存使用率、调用次数、健康状况等信息。这就需要我们有一套完备的服务监控体系，包括拓扑关系、监控（Metrics）、日志监控（Logging）、调用追踪（Trace）、告警通知、健康检查等，防患于未然。服务容错任何服务都不能保证100%不出问题，生产环境复杂多变，服务运行过程中不可避免的发生各种故障（宕机、过载等等），工程师能够做的是在故障发生时尽可能降低影响范围、尽快恢复正常服务。程序员为此避免被祭天，需要引入「熔断、隔离、限流和降级、超时机制」等「服务容错」机制来保证服务持续可用性。服务安全有些服务的敏感数据存在安全问题，「服务安全」就是对敏感服务采用安全鉴权机制，对服务的访问需要进行相应的身份验证和授权，防止数据泄露的风险，安全是一个长久的话题，在微服务中也有很多工作要做。服务治理说到「治理」一般都是有问题才需要治理，我们平常说环境治理、污染治理一个意思，微服务架构中的微服务越来越多，上面说的那些问题就更加显现，为了解决上面微服务架构缺陷「服务治理」就出现了。微服务的那些问题都要公司技术团队自己解决的话，如果不是大型公司有成熟的技术团队，估计会很头大。幸好，有巨人的肩膀可以借给我们站上去，通过引入「微服务框架」来帮助我们完成服务治理。微服务框架介绍一些业界比较成熟的微服务框架。Dubbo是阿里巴巴公司开源的一个Java高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和 Spring框架无缝集成。 Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现 。2011 年末对外开源，仅支持 Java 语言。官网：http://dubbo.apache.org/zh-cn/Tars腾讯内部使用的微服务架构 TAF（Total Application Framework）多年的实践成果总结而成的开源项目。 仅支持 C++ 语言，目前在腾讯内部应用也非常广泛。2017 年对外开源，仅支持 C++ 语言。源码： https://github.com/TarsCloud/Tars/本命鹅厂 TARS 框架介绍 PPT 已下载，不想自己麻烦去找的同学，拉到文末阅读原文链接获取****Motan是新浪微博开源的一个Java 框架。Motan 在微博平台中已经广泛应用，每天为数百个服务完成近千亿次的调用。于 2016 年对外开源，仅支持 Java 语言。官方指南： https://github.com/weibocom/motan/wiki/zh_userguidegRPC是Google开发的高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发。本身它不是分布式的，所以要实现上面的框架的功能需要进一步的开发。2015 年对外开源的跨语言 RPC 框架，支持多种语言。中文教程：https://doc.oschina.net/grpc?t=58008thrift最初是由 Facebook 开发的内部系统跨语言的高性能 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一， 跟 gRPC 一样，Thrift 也有一套自己的接口定义语言 IDL，可以通过代码生成器，生成各种编程语言的 Client 端和 Server 端的 SDK 代码，支持多种语言。微服务框架和RPC很多人对这两个概念有点混淆，微服务框架上面我们说过了，我们再来看下RPC的概念。什么是RPCRPC (Remote Procedure Call)远程过程调用是一个计算机通信协议。我们一般的程序调用是本地程序内部的调用，RPC允许你像调用本地函数一样去调用另一个程序的函数，这中间会涉及网络通信和进程间通信，但你无需知道实现细节，RPC框架为你屏蔽了底层实现。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 两者关系RPC和微服务框架的关系我的理解，微服务框架一般都包含了RPC的实现和一系列「服务治理」能力，是一套软件开发框架。我们可以基于这个框架之上实现自己的微服务，方便的利用微服务框架提供的「服务治理」能力和RPC能力，所以微服务框架也被有些人称作RPC框架。下一代微服务架构Service Mesh（服务网格）被认为是下一代微服务架构，Service Mesh并没有给我们带来新的功能，它是用于解决其他工具已经解决过的服务网络调用、限流、熔断和监控等问题，只不过这次是在Cloud Native 的 kubernetes 环境下的实现。 特点Service Mesh 有如下几个特点：应用程序间通讯的中间层轻量级网络代理应用程序无感知解耦应用程序的重试/超时、监控、追踪和服务发现目前两款流行的 Service Mesh 开源软件 [Istio](https://istio.io/) 和 [Linkerd](https://linkerd.io/)都可以直接在kubernetes 中集成，其中Linkerd已经成为云原生计算基金会 CNCF (Cloud Native Computing Foundation) 成员。Why Service Mesh为什么现有微服务架构已经解决的问题还要用Service Mesh呢？这个问题问的好。回答问题之前，先看下istio.io上对service mesh的解释，我觉得挺好的，摘抄出来：As a service mesh grows in size and complexity, it can become harder to understand and manage. Its requirements can include discovery, load balancing, failure recovery, metrics, and monitoring. A service mesh also often has more complex operational requirements, like A/B testing, canary rollouts, rate limiting, access control, and end-to-end authentication.makes it easy to create a network of deployed services with load balancing, service-to-service authentication, monitoring, and more, with few or no code changes in service code.  试着总结一下：随着微服务的增多复杂程度也增加，管理变得更加困难，微服务架构虽然解决了「网络调用、限流、熔断和监控」等问题，但大多数框架和开源软件对原有业务是侵入式的，也就是需要在业务服务程序中集成相关的「服务治理」组件。Service Mesh之于微服务，就像TCP/IP之于互联网，TCP/IP为网络通信提供了面向连接的、可靠的、基于字节流的基础通信功能，你不再需要关心底层的重传、校验、流量控制、拥塞控制。用了Service Mesh你也不必去操心「服务治理」的细节，不需要对服务做特殊的改造，所有业务之外的功能都由Service Mesh帮你去做了。它就像一个轻量级网络代理 对应用程序来说是透明，所有应用程序间的流量都会通过它，所以对应用程序流量的控制都可以在 serivce mesh 中实现 。写在最后在IT世界没有什么技术是永不过时的，微服务架构的演进就是一个例子，从单体程序到微服务架构，再到service mesh架构，我不知道下一个技术迭代点是什么时候，但我知道微服务架构肯定还会更新，IT人更应该建立终身学习习惯。   当然更重要的是拥有对技术的热情，热于拥抱变化、接受新技术，当我看到新技术我是兴奋的，内心os是厉害了，还能这么玩！，希望你也有这般热情，而不仅仅是面向工资编程，生活会有趣很多。   
“微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构”—- Martin Fowler的博客微服务的特征与界定***单体应用* vs 微服务架构 优点提升开发交流，每个服务足够内聚，足够小，代码容易理解；服务独立测试、部署、升级、发布；按需定制的DFX，资源利用率，每个服务可以各自进行x扩展和z扩展，而且，每个服务可以根据自己的需要部署到合适的硬件服务器上；每个服务按需要选择HA的模式，选择接受服务的实例个数；容易扩大开发团队，可以针对每个服务（service）组件开发团队；提高容错性（fault isolation），一个服务的内存泄露并不会让整个系统瘫痪；新技术的应用，系统不会被长期限制在某个技术栈上；缺点没有银弹，微服务提高了系统的复杂度；开发人员要处理分布式系统的复杂性；服务之间的分布式通信问题；服务的注册与发现问题；服务之间的分布式事务问题；数据隔离再来的报表处理问题；服务之间的分布式一致性问题；服务管理的复杂性，服务的编排；不同服务实例的管理。Chris Richardson提出的微服务的三维扩展模型：X轴，服务实例水平扩展，保证可靠性与性能；Y轴，功能的扩展，服务单一职责，功能独立；Z轴，数据分区，数据独立，可靠性保证；通信问题微服务的拆分一般会带来IPC通信的问题。通信机制需要完备可靠，服务之间的通信选择应尽量单一，从两个维度对通信的模式进行划分：第一个维度是一对一还是一对多：一对一：每个客户端请求有一个服务实例来响应。一对多：每个客户端请求有多个服务实例来响应。第二个维度是这些交互式同步还是异步：同步模式：客户端请求需要服务端即时响应，甚至可能由于等待而阻塞。异步模式：客户端请求不会阻塞进程，服务端的响应可以是非即时的。微服务架构认为，服务间通信应该就只有这几种模式。AC出于时延、编程模型等方面的考虑，提供了一套通信机制，业务之间的通信要按需选用。服务的发现与注册一般的微服务架构里都有两层API GetWay，一层是外部API GetWay，用于用户访问系统；一层是内部API GetWay，内部服务之间的API GetWay。内部API GetWay要解决的问题就是服务发现和服务注册。从这也能看出来，为什么通信的方式要尽量单一，API GetWay有一项工作就是协议转换。微服务可能是HA主备的，也可能是LB的，怎么找到一个服务？有两种思路，客户端发现（左图）,客户端去注册中心查询服务实例列表，自行选择；另一种是服务端发现（右图），添加LB模块，客户端把请求发向LB，由LB根据负载均衡策略选择服务实例；微服务注册表的典型实现： ETCD : 是一个高可用，分布式的，一致性的，键值表，用于共享配置和服务发现。两个著名案例包括Kubernetes和Cloud Foundry。 ZK: 是一个广泛使用，为分布式应用提供高性能整合的服务。Apache ZooKeeper最初是Hadoop的子项目，现在已经变成顶级项目。微服务架构的部署**微服务架构对于部署的要求**：部署速率，Amazon与NetFlix都有千个服务，每个服务都有持续部署的要求，Amazon的服务每秒都会部署一次；部署自动化，一切都要自动化，IaaS与PaaS解决I层与P层自动化部署，微服务有自动部署与运维工具，并实现Auto-Scaling；部署提供基础机制，为实现分布式部署要求，部署机制一般都有资源池化、服务的生命周期来看，部署服务 与服务注册是一体的； 部署的粒度：VM: 部署系统管理的VM的生命周期，如当前AC的iDeploy部署，把AC部署拆分为每个VM的安装、配置与启动；这种方式粒度粗，支撑不了微服务的部署(除非一个服务占用一个VM); App: 管理应用的生命周期及部署形态，生命周期分为部署、配置、启动、升级等，部署形态有主备、LB、Daemon等；Container: 相比于APP，容器有更好的隔离性和移植性；微服务：一般的微服务要么是APP，要么是Container，但AC就不是。受限于ONOS架构，我们的服务是一组feature；MS部署的解决方案：TOSCA: 云应用拓扑标准，一种描述云化部署的DSL，我司主推一个标准，PaaS的部署系统和MANO用的都是TOSCA；Kubernetes:Google开源的容器管理系统，提出了Pod/Service/Labels等概念，以ETCD为中心，PaaS基于K8S开发出了我司的云化部署平台；Mesosphere:DCOS，数据中心操作系统，基于mesos实现资源池化，有自身的编排工具；分布式LAB基于DCOS的思想做出了一套部署与集群管理系统(HASEN)；微服务的划分微服务的划分主要是保证微服务功能内聚，职责单一。一般使用DDD(Domain Drive Design)的思想与方法对微服务进行划分，这种方法有点类似于数据库ER图的划分，不断分解数据，保证关系型数据库符合原子性、冗余性的范式要求。当然，微服务的划分比数据表划分更复杂，也没有微服务范式的概念，但思想是一致的。更多的内容，请参考《领域驱动设计》这本书。分布式一致性有两个大的思路：全局的分布式事务；事件驱动；分布式事务就是现在AC的思路，在设计开发中；事件驱动，忽略了事务的概念，由每个服务在应用层面保存服务的状态，服务之间的通信使用事件机制通知；此种方法可以保证微服务间的独立性，但把问题交给了服务的设计者；具体事件驱动的案例见参考材料；数据隔离问题微服务之间数据隔离可以保证服务的独立升级与部署，数据隔离有三个维度：数据表级隔离；数据表之间独立，没有外键关系；数据库级隔离；不同服务有不同的数据库；DBMS级隔离；不同服务有不同的数据库管理系统；一般做到数据库级隔离就可以了，服务之间的数据交换使用服务间接口。从单体到微服务微服务架构是一个衍生架构，都是从单体架构演化而来的。因为微服务架构本身的复杂性，初创系统出于快速开发、快速验证的考虑，很少在一开始就使用微服务架构。加之微服务的概念在这两年才火，大型单体应用也是看到了开发与维护的成本在不断增加，才会有转型微服务的动力。因此，如何从单体到微服务是一个普遍问题。从单体到微服务的原则：逐步演进，不要全部重构**。全部重构，带来极大的成本和风险，系统会有很长的不稳定期。而且，最终的效果也不会很好，在设计时很难想到所有问题。微服务架构的演化思路应该是一步步铺基础设施，一点点拆分微服务。 DevOps与微服务架构DevOps是09年提出来的概念，但一直没有太火。直到14年，容器与微服务架构的提出，DevOps才得到了快速的发展。DevOps不单是一个实现自动化的工具链，而是组织、流程与技术的结合。组织上强调全栈团队、团队特性专一、团队自治；技术上打通开发与运维；流程上强调端到端、可视化、灰度升级、A/B测试等。对于DevOps，MS不是必须的，但MS为DevOps提供了最好的架构支撑，对于组织和流程的要求也是一致的。所以，也有人称MS是DevOps架构。 我观察业界这么多年，做微服务没几个好死的。据说马丁是微服务最初的提出者，但是我看了他的提法，狗屁不通。1， 微服务的起因是服务化普及以后带来的高开发成本、协作成本2， 但服务化本身是正确的，所以只能在降低成本、轻量级上做改进；而不是推翻。微服务的命名大概就是这么个初衷。3， 但独立部署比内部jar性能高？成本低？运维成本低？Restful比RPC性能高？成本低？运维成本低？拆分比合并成本低？效率高？这些全是增加成本的。他病看对了，药开错了。只有名字是对的，药方基本全错。尽管如此，我依然推崇微服务。不过不推荐大家去拥抱他——仅仅用，但是不要深入用，不要拥抱。比如框架换个皮，从以前框架换成微服务，你就能立即享受微服务的优势了。但是如果你进一步拥抱，拆分，独立部署。。。。。麻烦等着你呢（restful相对没那么重要，仅仅10%以内的性能消耗，并没有带来其他太大的弊病，但是带来了体系开放性——虽然99%的情况下没什么用。但是也凑合吧）本世纪初，IT圈面临的问题是信息化死局：上ERP是找死，不上是等死。为啥上了找死，不上等死？早期的信息化系统都是全家桶式的全套解决方案。比如买了个ERP挺合适，但是OA，财务什么的可能不合适。但是不能分开用，因为是封闭体系、不开放（闭环？）于是财务、OA什么的就得捏着鼻子用。业务不兼容？业务改造啊。。。。客户不接受？……这是找死。不上呢，你得想清楚了。未来的企业是不是还用算盘，容得下老古董。那是等死。SOA解决了这个问题。SOA在08年-10年左右开始大热、成熟。其中是走了一些“弯路”的。比如早起SOA方案疯狂推荐的时ESB，但今天ESB罕有人用。用的多数是拆分+RPC（dubbo等）这种P2PRPC的方案。这个“弯路”加引号是因为今天再去审视dubbo/springcloud等这些P2PRC的SOA架构普及以后，发现了很多问题，比如服务粒度细、体系架构复杂、开发效率低、服务治理难，监控维护难等……需要一大堆基础设施建设或者说擦屁股方案打补丁。这么看起来，ESB看起来更优秀，只不过门槛高，但是和那一大堆擦屁股方案比起来，他简单到极致了。P2PRPC才是弯路啊。其实这种弯路，OSGI（支付宝要不要给我点个赞，顺便把你们的弯路分享一下，还有你们在DDD上的“成就”），RIA，RCP，WEBSERVICE一样都走过。我们今天的微服务、中台一样正在走这个弯路。回顾所有这些曲折的话，你会发现并不一定道路是曲折的，前途是光明的。比如有些就一路曲折到火葬场。但是，对一个人成长最大的其实是弯路。走弯路之前你想了什么？是不是狐狸精勾引你了？还是你有什么心魔？你为什么做了这个选择 ？其中关键的要素是什么？我们漏掉了什么？自己还有哪些缺点？我们对现实世界的规律有没有多一点认识？以后怎么改进？所以其实相比现在业界各种效果不确定的所谓技术盛宴营销，我其实更想听他们走了啥弯路，开心开心，也更有收获一点。我在某宝的时候，就发现有个规律，内部最核心的最有用的技术架构和思想，从来不分享。外界几乎一个字都搜索不到，那些没什么用，但是看起来特别难，特别高大上的，分享的特别欢乐。外面趋之若鹜。这其实是一种很委婉的劝降行为：嗨，这事太难了，你不行，赶紧投降吧。我很牛逼的，都用我的。当然，绝大多数人都不会投降，但是的确会认可某里技术牛逼的现实。并且上进的人会追求进步，然后走了弯路。不过人家并没有说谎啊。所以，现在技术圈的文章，技术上看一半，信只能信1/4；还得多琢磨琢磨技术以外的因素。只是 看看，寻个思路，想还是要自己想，以自己为主。微服务、中台等，一样的 古人说圣人不止，大盗不止；原理就是大家推崇什么，就坏人一定就伪装什么，推崇的越厉害，坏人就越具有破坏性。技术这词，现在就这意思。现代人说：钱多的地方是非多。IT圈就能例外？每个人脸上写着他是天生的技术人？技术是纯粹的，但是技术后面的人是不纯粹的。技术不会自己张嘴说话。
一、全面了解微服务a : 4个典型特点1.单个服务尽量专注一件事情，高内聚、低耦合；2.进程隔离；3.每个服务可以独立的开发、测试、构建、部署；4.小且灵活；b : 无与伦比的优点1.交付周期每个服务可以独立的开发、测试和交付，降低周期；2.快速沟通小团队开发，降低代码耦合度导致的沟通成本；业务按服务拆分，新人不需要了解整体架构，上手快；3.定制化可以根据市场需求，灵活多变的组合出新的业务场景；4.隔离性进程隔离方式，故障范围有效控制；5.技术栈可以根据需求按服务选择不同技术栈；6.演进优化可以按照服务粒度进行演进优化；二、微服务基础架构关键点下面脑图中芒果色标注的七个模块，被认为认为是构建微服务 2.0 技术栈的核心模块，本文后面的选型会分别基于这些模块展开。对于每个模块我也列出一些核心架构关注点，在选择具体产品时，需要尽可能覆盖到这些关注点。下图是我近期工作总结和参考的一个微服务技术体系，我想同时分享给一线架构师或者工程师参考，其中粉红色标注的模块是和微服务关系最密切的模块，大家在做技术选型时，可以同时对照这个体系。三、 服务框架选型服务框架是一个比较成熟的领域，有太多可选项。Spring Boot/Cloud 由于 Spring 社区的影响力和 Netflix 的背书，目前可以认为是构建 Java 微服务的一个社区标准，Spring Boot 目前在 GitHub 上有超过 20k 星。基于 Spring 的框架本质上可以认为是一种 RESTful 框架（不是 RPC 框架），序列化协议主要采用基于文本的 JSON，通讯协议一般基于 HTTP。RESTful 框架天然支持跨语言，任何语言只要有 HTTP 客户端都可以接入调用，但是客户端一般需要自己解析 payload。目前 Spring 框架也支持 Swagger 契约编程模型，能够基于契约生成各种语言的强类型客户端，极大方便不同语言栈的应用接入，但是因为 RESTful 框架和 Swagger 规范的弱契约特性，生成的各种语言客户端的互操作性还是有不少坑的。Dubbo 是阿里多年构建生产级分布式微服务的技术结晶，服务治理能力非常丰富，在国内技术社区具有很大影响力，目前 github 上有超过 16k 星。Dubbo 本质上是一套基于 Java 的 RPC 框架，当当 Dubbox 扩展了 Dubbo 支持 RESTful 接口暴露能力。Dubbo 主要面向 Java 技术栈，跨语言支持不足是它的一个弱项，另外因为治理能力太丰富，以至于这个框架比较重，完全用好这个框架的门槛比较高，但是如果你的企业基本上投资在 Java 技术栈上，选 Dubbo 可以让你在服务框架一块站在较高的起点上，不管是性能还是企业级的服务治理能力，Dubbo 都做的很出色。新浪微博开源的 Motan（GitHub 4k stars）也不错，功能和 Dubbo 类似，可以认为是一个轻量裁剪版的 Dubbo。gRPC 是谷歌近年新推的一套 RPC 框架，基于 protobuf 的强契约编程模型，能自动生成各种语言客户端，且保证互操作。支持 HTTP2 是 gRPC 的一大亮点，通讯层性能比 HTTP 有很大改进。Protobuf 是在社区具有悠久历史和良好口碑的高性能序列化协议，加上 Google 公司的背书和社区影响力，目前 gRPC 也比较火，GitHub 上有超过 13.4k 星。目前看 gRPC 更适合内部服务相互调用场景，对外暴露 RESTful 接口可以实现，但是比较麻烦（需要 gRPC Gateway 配合），所以对于对外暴露 API 场景可能还需要引入第二套 RESTful 框架作为补充。总体上 gRPC 这个东西还比较新，社区对于 HTTP2 带来的好处还未形成一致认同，建议谨慎投入，可以做一些试点。四、 运行时支撑服务选型运行时支撑服务主要包括服务注册中心，服务路由网关和集中式配置中心三个产品。服务注册中心，如果采用 Spring Cloud 体系，则选择 Eureka 是最佳搭配，Eureka 在 Netflix 经过大规模生产验证，支持跨数据中心，客户端配合 Ribbon 可以实现灵活的客户端软负载，Eureka 目前在 GitHub 上有超过 4.7k 星；Consul 也是不错选择，天然支持跨数据中心，还支持 KV 模型存储和灵活健康检查能力，目前在 GitHub 上有超过 11k 星。服务网关也是一个比较成熟的领域，有很多可选项。如果采用 Spring Cloud 体系，则选择 Zuul 是最佳搭配，Zuul 在 Netflix 经过大规模生产验证，支持灵活的动态过滤器脚本机制，异步性能不足（基于 Netty 的异步 Zuul 迟迟未能推出正式版）。Zuul 网关目前在 github 上有超过 3.7k 星。基于 Nginx/OpenResty 的 API 网关 Kong 目前在 github 上比较火，有超过 14.1k 星。因为采用 Nginx 内核，Kong 的异步性能较强，另外基于 lua 的插件机制比较灵活，社区插件也比较丰富，从安全到限流熔断都有，还有不少开源的管理界面，能够集中管理 Kong 集群。配置中心，Spring Cloud 自带 Spring Cloud Config（GitHub 0.75k stars），个人认为算不上生产级，很多治理能力缺失，小规模场景可以试用。个人比较推荐携程的 Apollo 配置中心，在携程经过生产级验证，具备高可用，配置实时生效（推拉结合），配置审计和版本化，多环境多集群支持等生产级特性，建议中大规模需要对配置集中进行治理的企业采用。Apollo 目前在 github 上有超过 3.4k 星。五、服务监控选型主要包括日志监控，调用链监控，Metrics 监控，健康检查和告警通知等产品。ELK 目前可以认为是日志监控的标配，功能完善开箱即用，ElasticSearch 目前在 GitHub 上有超过 28.4k 星。Elastalert(GitHub 4k stars) 是 Yelp 开源的针对 ELK 的告警通知模块。调用链监控目前社区主流是点评 CAT（GitHub 4.3k stars），Twitter 之前开源现在由 OpenZipkin 社区维护的 Zipkin（GitHub 7.5k stars）和 Naver 开源的 Pinpoint（GitHub 5.3k stars）。个人比较推荐点评开源的 CAT，在点评和国内多家互联网公司有落地案例，生产级特性和治理能力较完善，另外 CAT 自带告警模块。下面是我之前对三款产品的评估表，供参考。Metrics 监控主要依赖于时间序列数据库 (TSDB)，目前较成熟的产品是 StumbleUpon 公司开源的基于 HBase 的 OpenTSDB（基于 Cassandra 的 KariosDB 也是一个选择，GitHub 1.1k stars，它基本上是 OpenTSDB 针对 Cassandra 的一个改造版），OpenTSDB 具有分布式能力可以横向扩展，但是相对较重，适用于中大规模企业，OpenTSDB 目前在 GitHub 上有近 2.9k 星。OpenTSDB 本身不提供告警模块，Argus（GitHub 0.29k 星）是 Salesforce 开源的基于 OpenTSDB 的统一监控告警平台，支持丰富的告警函数和灵活的告警配置，可以作为 OpenTSDB 的告警补充。近年也出现一些轻量级的 TSDB，如 InfluxDB（GitHub 12.4k stars）和 Prometheus（GitHub 14.3k stars），这些产品函数报表能力丰富，自带告警模块，但是分布式能力不足，适用于中小规模企业。Grafana（GitHub 19.9k stars）是 Metrics 报表展示的社区标配。社区还有一些通用的健康检查和告警产品，例如 Sensu（GitHub 2.7k stars），能够对各种服务（例如 Spring Boot 暴露的健康检查端点，时间序列数据库中的 metrics，ELK 中的错误日志等）定制灵活的健康检查 (check)，然后用户可以针对 check 结果设置灵活的告警通知策略。Sensu 在 Yelp 等公司有落地案例。其它类似产品还有 Esty 开源的 411（GitHub 0.74k 星）和 Zalando 的 ZMon(GitHub 0.15k 星)，它们是分别在 Esty 和 Zalando 落地的产品，但是定制 check 和告警配置的使用门槛比较高，社区不热，建议有定制自研能力的团队试用。ZMon 后台采用 KairosDB 存储，如果企业已经采用 KariosDB 作为时间序列数据库，则可以考虑 ZMon 作为告警通知模块。六、服务容错选型针对 Java 技术栈，Netflix 的 Hystrix（github 12.4k stars）把熔断、隔离、限流和降级等能力封装成组件，任何依赖调用（数据库，服务，缓存）都可以封装在 Hystrix Command 之内，封装后自动具备容错能力。Hystrix 起源于 Netflix 的弹性工程项目，经过 Netflix 大规模生产验证，目前是容错组件的社区标准，GitHub 上有超 12k 星。其它语言栈也有类似 Hystrix 的简化版本组件。Hystrix 一般需要在应用端或者框架内埋点，有一定的使用门槛。对于采用集中式反向代理（边界和内部）做服务路由的公司，则可以集中在反向代理上做熔断限流，例如采用 Nginx（GitHub 5.1k stars）或者 Kong（GitHub 11.4k stars）这类反向代理，它们都插件支持灵活的限流容错配置。Zuul 网关也可以集成 Hystrix 实现网关层集中式限流容错。集中式反向代理需要有一定的研发和运维能力，但是可以对限流容错进行集中治理，可以简化客户端。七、 后台服务选型后台服务主要包括消息系统，分布式缓存，分布式数据访问层和任务调度系统。后台服务是一个相对比较成熟的领域，很多开源产品基本可以开箱即用。消息系统，对于日志等可靠性要求不高的场景，则 Apache 顶级项目 Kafka（GitHub 7.2k stars）是社区标配。对于可靠性要求较高的业务场景，Kafka 其实也是可以胜任，但企业需要根据具体场景，对 Kafka 的监控和治理能力进行适当定制完善，Allegro 公司开源的 hermes（GitHub 0.3k stars）是一个可参考项目，它在 Kafka 基础上封装了适合业务场景的企业级治理能力。阿里开源的 RocketMQ（GitHub 3.5k 星）也是一个不错选择，具备更多适用于业务场景的特性，目前也是 Apache 顶级项目。RabbitMQ（GitHub 3.6k 星）是老牌经典的 MQ，队列特性和文档都很丰富，性能和分布式能力稍弱，中小规模场景可选。对于缓存治理，如果倾向于采用客户端直连模式（个人认为缓存直连更简单轻量），则 SohuTv 开源的 cachecloud（GitHub 2.5k stars）是一款不错的 Redis 缓存治理平台，提供诸如监控统计，一键开启，自动故障转移，在线伸缩，自动化运维等生产级治理能力，另外其文档也比较丰富。如果倾向采用中间层 Proxy 模式，则 Twitter 开源的 twemproxy（GitHub 7.5k stars）和 CodisLab 开源的 codis（GitHub 6.9k stars）是社区比较热的选项。对于分布式数据访问层，如果采用 Java 技术栈，则当当开源的 shardingjdbc（GitHub 3.5k stars）是一个不错的选项，分库分表逻辑做在客户端 jdbc driver 中，客户端直连数据库比较简单轻量，建议中小规模场景采用。如果倾向采用数据库访问中间层 proxy 模式，则从阿里 Cobar 演化出来的社区开源分库分表中间件 MyCAT（GitHub 3.6k stars）是一个不错选择 。proxy 模式运维成本较高，建议中大规模场景，有一定框架自研和运维能力的团队采用。任务调度系统，个人推荐徐雪里开源的 xxl-job（GitHub 3.4k stars），部署简单轻量，大部分场景够用。当当开源的 elastic-job（GitHub 3.2k stars）也是一个不错选择，相比 xxl-job 功能更强一些也更复杂。八、 服务安全选型对于微服务安全认证授权机制一块，目前业界虽然有 OAuth 和 OpenID connect 等标准协议，但是各家具体实现的做法都不太一样，企业一般有很多特殊的定制需求，整个社区还没有形成通用生产级开箱即用的产品。有一些开源授权服务器产品，比较知名的如 Apereo CAS（GitHub 3.6k stars），JBoss 开源的 keycloak（GitHub 1.9 stars），spring cloud security 等，大都是 opinionated（一家观点和做法）的产品，同时因支持太多协议造成产品复杂，也缺乏足够灵活性。个人建议基于 OAuth 和 OpenID connect 标准，在参考一些开源产品的基础上（例如 Mitre 开源的 OpenID-Connect-Java-Spring-Server，GitHub 0.62k stars），定制自研轻量级授权服务器。Wso2 提出了一种微服务安全的参考方案，建议参考，该方案的关键步骤如下：\1. 使用支持 OAuth 2.0 和 OpenID Connect 标准协议的授权服务器（个人建议定制自研）；2. 使用 API 网关作为单一访问入口，统一实现安全治理；3. 客户在访问微服务之前，先通过授权服务器登录获取 access token，然后将 access token 和请求一起发送到网关；4. 网关获取 access token，通过授权服务器校验 token，同时做 token 转换获取 JWT token。5. 网关将 JWT Token 和请求一起转发到后台微服务。6. JWT 中可以存储用户会话信息，该信息可以传递给后台的微服务，也可以在微服务之间传递，用作认证授权等用途；7. 每个微服务包含 JWT 客户端，能够解密 JWT 并获取其中的用户会话信息。8. 整个方案中，access token 是一种 by reference token，不包含用户信息可以直接暴露在公网上；JWT token 是一种 by value token，可以包含用户信息但不暴露在公网上。九、 服务部署平台选型容器已经被社区接受为交付微服务的一种理想手段，可以实现不可变（immutable）发布模式。一个轻量级的基于容器的服务部署平台主要包括容器资源调度，发布系统，镜像治理，资源治理和 IAM 等模块。集群资源调度系统：屏蔽容器细节，将整个集群抽象成容器资源池，支持按需申请和释放容器资源，物理机发生故障时能够实现自动故障迁移 (fail over)。目前 Google 开源的 Kubernetes，在 Google 背书和社区的强力推动下，基本已经形成市场领导者地位，GitHub 上有 31.8k 星，社区的活跃度已经远远超过了 mesos（GitHub 3.5k stars）和 swarm 等竞争产品，所以容器资源调度建议首选 K8s。当然如果你的团队有足够定制自研能力，想深度把控底层调度算法，也可以基于 Mesos 做定制自研。镜像治理：基于 Docker Registry，封装一些轻量级的治理功能。VMware 开源的 harbor(GitHub 3.5k stars) 是目前社区比较成熟的企业级产品，在 Docker Registry 基础上扩展了权限控制，审计，镜像同步，管理界面等治理能力，可以考虑采用。资源治理：类似于 CMDB 思路，在容器云环境中，企业仍然需要对应用 app，组织 org，容器配额和数量等相关信息进行轻量级的治理。目前这块还没有生产级的开源产品，一般企业需要根据自己的场景定制自研。发布平台：面向用户的发布管理控制台，支持发布流程编排。它和其它子系统对接交互，实现基本的应用发布能力，也实现如蓝绿，金丝雀和灰度等高级发布机制。目前这块生产级的开源产品很少，Netflix 开源的 spinnaker（github 4.2k stars）是一个，但是这个产品比较复杂重量（因为它既要支持适配对接各种 CI 系统，同时还要适配对接各种公有云和容器云，使得整个系统异常复杂），一般企业建议根据自己的场景定制自研轻量级的解决方案。IAM：是 identity &amp; access management 的简称，对发布平台各个组件进行身份认证和安全访问控制。社区有不少开源的 IAM 产品，比较知名的有 Apereo CAS（GitHub 3.6k stars），JBoss 开源的 keycloak（GitHub 1.9 stars）等。但是这些产品一般都比较复杂重量，很多企业考虑到内部各种系统灵活对接的需求，都会考虑定制自研轻量级的解决方案。考虑到服务部署平台目前还没有端到端生产级解决方案，企业一般需要定制集成，下面给出一个可以参考的具备轻量级治理能力的发布体系：简化发布流程如下：1. 应用通过 CI 集成后生成镜像，用户将镜像推到镜像治理中心；2. 用户在资产治理中心申请发布，填报应用，发布和配额相关信息，然后等待审批通过；3. 发布审批通过，开发人员通过发布控制台发布应用；4. 发布系统通过查询资产治理中心获取发布规格信息；5. 发布系统向容器云发出启动容器实例指令；6. 容器云从镜像治理中心拉取镜像并启动容器；7. 容器内服务启动后自注册到服务注册中心，并保持定期心跳；8. 用户通过发布系统调用服务注册中心调拨流量，实现蓝绿，金丝雀或灰度发布等机制；9. 网关和内部微服务客户端定期同步服务注册中心上的服务路由表，将流量按负载均衡策略分发到新的服务实例上。另外，持续交付流水线（CD Pipeline）也是微服务发布重要环节，这块主要和研发流程相关，一般需要企业定制，下面是一个可供参考的流水线模型，在镜像治理中心上封装一些轻量级的治理流程，例如只有通过测试环境测试的镜像才能升级发布到 UAT 环境，只有通过 UAT 环境测试的镜像才能升级发布到生产环境，通过在流水线上设置一些质量门，保障应用高质量交付到生产。十、总结注意，本文限于篇幅，对测试和 CI 等环节没有涉及，但它们同样是构建微服务架构的重要环节，也有众多成熟的开源产品可选。技术选型虽然重要，但还只是微服务建设的一小部分工作，选型后的产品要在企业内部真正落地，形成完整的微服务技术栈体系，则后续还有大量集成、定制、治理、运维和推广等工作。以上是理论部分，具体实践请详细参照各大公司的系统微服务演进，包括华为、阿里、百度、滴滴、豆瓣、七牛、小米、360、58等公司的实践案例以及两本最佳学习微服务的电子书，王磊著的《微服务架构与实践》以及国外Sam Newman著的《微服务设计》。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/12/04/2014-12-04-java-is-compiled-or-interpreted/">Java是编译型语言还是解释型语言</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-12-04</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/12/04/2014-12-04-java-is-compiled-or-interpreted/">
                    <p>
                        
                            大多数开发人员都知道，Java源文件需要编译成.class文件才能在JVM中运行。如果继续追问，许多开发人员还会告诉你说.class中的字节码首先会被JVM解释，但是在稍后即时（JIT）编译。然而很多人将字节码含糊地理解为“在某种虚构的或者简化的CPU上运行的机器码”。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/it/" rel="tag">it</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/29/%E5%9B%9B%E7%A7%8DJavaEE%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/">四种JavaEE架构简介</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-29</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/29/%E5%9B%9B%E7%A7%8DJavaEE%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/">
                    <p>
                        
                            四种JavaEE架构简介1. 传统三层架构配图是一个基于MVC的三层架构, 大致可以分成表现层, 业务层和持久层
表现层负责接收请求和转发请求
业务层主要负责处理请求, 值得注意的是事务管理, 日志记录等操作通常也是封装在这层中
持久层主要负责数据库与实体之间的操作
我们可以使用框架来简化各层的开发, 例如表现层使用SpringMVC或Strut2, 持久层使用Mybatis或Hibernate, 使用Spring管理三层之间的关系

2. 集群架构集群属于水平拓展.
传统三层架构中存在许多问题, 比如业务层中不同模块占用系统资源的比例相差太大, 导致占用系统资源, 可以使用集群解决这类问题.
在集群架构, 一般由这么一个重要的角色, 那就是反向代理服务器, 它的主要任务是实现负载均衡, 接收用户请求, 转发到目标服务器.
反向代理服务器可以使用nginx实现.

3. 分布式架构多个模块完成一个功能.
每个模块都可以搭建集群 -&gt; 高可用

4. 微服务架构根据产品的业务功能模块来划分服务的种类, 这属于垂直划分.
客户端可以通过基于HTTP或RPC的方式来调用微服务, 这样做的目的是为了降低调用所产生的性能开销.
每个模块也可搭建集群 -&gt; 高可用

三种轻量级API调用服务 - 使用service gateway和service register实现客户端与微服务之间的调用(实现通信)SOA实现两个系统之间通信的三种方式

dubbo体系结构:
一个典型的基于SOA的电商项目架构:

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/25/2013-11-25-java-reflect-set-value/">Java使用反射设置值</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-25</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/25/2013-11-25-java-reflect-set-value/">
                    <p>
                        
                            今天敲代码，遇到个问题，需要实现一个方法：给一个类的成员变量设置值，数字类型的设置为0，布尔类型的设置为false，其他设置为null，变量不知道是什么类型的。
这里面有几个要点：

给变量设值
区分变量是什么类型（数字，布尔或其他）
基本类型的处理情况

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/Field/" rel="tag">Field</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/reflect/" rel="tag">reflect</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/21/springboot%E5%85%A5%E9%97%A8/">springboot入门</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-21</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/21/springboot%E5%85%A5%E9%97%A8/">
                    <p>
                        
                            Spring Boot -01- 快速入门篇（图文教程）今天开始不断整理 Spring Boot 2.0 版本学习笔记，大家可以在博客看到我的笔记，然后大家想看视频课程也可以到【慕课网】手机 app，去找【Spring Boot 2.0 深度实践】的课程，令人开心的是，课程完全免费！
什么是 Spring Boot？
Spring Boot 是由 Pivotal 团队提供的全新框架。Spring Boot 是所有基于 Spring Framework 5.0 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。
设计目的： 用来简化新 Spring 应用的初始搭建以及开发过程。
从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。用大佬的话来理解，就是 spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点：
（1）为所有 Spring 开发提供一个更快更广泛的入门体验。
（2）零配置。无冗余代码生成和XML 强制配置，遵循“约定大于配置” 。
（3）集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。
（4）提供一系列大型项目常用的非功能性特征，如嵌入式服务器、安全性、度量、运行状况检查、外部化配置等。
（5）Spring Boot 不是Spring 的替代者，Spring 框架是通过 IOC 机制来管理 Bean 的。Spring Boot 依赖 Spring 框架来管理对象的依赖。Spring Boot 并不是Spring 的精简版本，而是为使用 Spring 做好各种产品级准备
Spring Boot 在应用中的角色Spring Boot 是基于 Spring Framework 来构建的，Spring Framework 是一种 J2EE 的框架（什么是 J2EE？）Spring Boot 是一种快速构建 Spring 应用Spring Cloud 是构建 Spring Boot 分布式环境，也就是常说的云应用Spring Boot 中流砥柱，承上启下

环境准备
（1）JDK 环境必须是 1.8 及以上，传送门：jdk1.8.191 下载
（2）后面要使用到 Maven 管理工具 3.2.5 及以上版本，所以会先介绍 Maven 的安装与配置
（3）开发工具建议使用 IDEA，也可以 MyEclipse，为了实现一站式服务，传送门：
IDEA 破解（原文是PyCharm的，步骤完全一样，Webstorm 也可以破解）
MyEclipse 2018 安装与破解



Maven 安装与环境变量配置（1）Maven 安装：

在官网下载：http://maven.apache.org/download.cgi


（2）Maven 配置环境变量：
解压到一个路径，然后配置环境变量：

新建变量名：MAVEN_HOME 变量值：D:\server\apache-maven-3.6.0（这是我的 MAVEN 路径）
编辑变量名：Path 在最前面加上：%MAVEN_HOME%\bin

（3）检查是否配置成功：
在命令行输入：
12mvn -V1

然后会一大堆东西：
（4）配置 maven 仓库：
1.打开 maven 文件夹下的 config 文件夹下的 settings.xml；2.找到 localRepository 标签，此时是被注释掉的，我们解除注释，然后配置一个路径，例如：D:/space/MavenRepository/maven_jar，这样以后 MAVEN 管理下载的jar 包都会在这个路径下。【注意】：注意结点的位置，先找到注释掉的部分，贴在下面
12&lt;localRepository&gt;D:\space\MavenRepository\maven_jar&lt;&#x2F;localRepository&gt;1


3.配置远程仓库，找到 mirrors 标签
12345678&lt;!--远程仓库--&gt;&lt;mirror&gt;　　&lt;id&gt;aliyun&lt;&#x2F;id&gt;　　&lt;name&gt;aliyun Maven&lt;&#x2F;name&gt;　　&lt;mirrorOf&gt;*&lt;&#x2F;mirrorOf&gt;   &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt;&lt;&#x2F;mirror&gt;1234567


4.当然我们需要先建这样一个目录结构，然后还要把settings.xml 复制一份到 D:/space/MavenRepository 下

（5）在 idea 配置 maven：点击【File】&gt;【Settings】&gt;搜索【Maven】，按截图配置安装目录和选择刚刚 settings 配置文件；选择完settings之后，本地仓库自动改成settings文件中配置的；点击apply，再点击ok即配置完成。

使用 idea 快速搭建 Spring Boot第一步：新建 Spring Initializr 项目：

（1）选择 Spring Initializr（2）选择 SDK，点击【new】这里就是使用 JAVA SDK 要求版本 1.8+，选择你默认安装在 C:\Program Files\Java\jdk1.8.0_191 目录：
（3）然后选择默认的 url （不用管）点击【Next】：

（4）然后填写一下项目的信息：

（5）先勾选上 Web 依赖：
（6）勾选 SQl 下的 MySQL，MyBatis 依赖：（根据自己的项目选择，后面可加）
（7）选择好项目的位置，点击【Finish】：

（7）如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下：

项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么：

SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序
SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文
application.properties：一个空的 properties 文件，可以根据需要添加配置属性
pom.xml： Maven 构建说明文件

第二步：HelloController
在 【main/java/com.xpwi.springboot】包下新建一个【HelloController】：

1234567891011121314151617181920package com.xpwi.springboot;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;** * 测试控制器 * * @author: @肖朋伟CSDN * @create: 2018-11-18 *&#x2F;@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;&#x2F;hello&quot;)    public String hello() &#123;        return &quot;Hello Spring Boot!&quot;;    &#125;&#125;12345678910111213141516171819

第三步：利用 IDEA 启动 Spring Boot
（1）我们回到 SpringbootApplication 这个类中，然后右键点击运行：

（2）会提示 Maven 导包，点击 import
（3）注意：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat等待一会儿就会看到下方的成功运行的提示信息：

（4）此时，可以看到我们的 Tomcat 运行在 8080 端口，我们来访问下面地址试一下：
12http:&#x2F;&#x2F;localhost:8080&#x2F;hello1


Spring Boot 项目文件介绍一、解析 pom.xml 文件：
（1）让我们来看看默认生成的 pom.xml 文件中到底有些什么：
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;com.xpwi&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springboot&lt;&#x2F;artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;    &lt;packaging&gt;jar&lt;&#x2F;packaging&gt;    &lt;name&gt;springboot&lt;&#x2F;name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;    &lt;&#x2F;parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;    &lt;&#x2F;properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;&lt;&#x2F;project&gt;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051

（2）我们可以看到一个比较陌生一些的标签 ，这个标签是在配置 Spring Boot 的父级依赖：
1234567&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.1.0.RELEASE&lt;&#x2F;version&gt;        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;    &lt;&#x2F;parent&gt;123456

有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的 Maven 默认依赖，使用它之后，常用的包依赖就可以省去 version 标签。
关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\repository\org\springframework\boot\spring-boot-dependencies\2.1.0.RELEASE\spring-boot-dependencies-2.1.0.RELEASE.pom 文件来查看，挺长的…
二、应用入口类 SpringbootApplication.java
Spring Boot 项目通常有一个名为 *Application 的入口类，入口类里有一个 main 方法， 这个 main 方法其实就是一个标准的 Javay 应用的入口方法。
@SpringBootApplication 是 Spring Boot 的核心注解，它是一个组合注解，该注解组合了：**@Configuration、@EnableAutoConfiguration、@ComponentScan；** 若不是用 @SpringBootApplication 注解也可以使用这三个注解代替。

其中，**@EnableAutoConfiguration 让 Spring Boot 根据类路径中的 jar 包依赖为当前项目进行自动配置**，例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。
Spring Boot 还会自动扫描 @SpringBootApplication 所在类的同级包以及下级包里的 Bean ，所以入口类建议就配置在 grounpID + arctifactID 组合的包名下（这里为 com.xpwi.springboot 包）

三、Spring Boot 的配置文件：
Spring Boot 使用一个全局的配置文件 application.properties 或 application.yml，放置在【src/main/resources】目录或者类路径的 /config 下。
Spring Boot 不仅支持常规的 properties 配置文件，还支持 yaml 语言的配置文件。yaml 是以数据为中心的语言，在配置数据的时候具有面向对象的特征。
Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。
修改 properties 配置文件实例：
（1）打开 resources 下的 application.properties

（2）在这里我们可以设置访问的端口，将 Tomcat 默认端口设置为 8080 （默认的不修改） ，并将默认的访问路径从 “/” 修改为 “/cn” 时，再访问 http://localhost:8080/ 是什么都没有的，此时要访问 hello 是要使用 http://localhost:8080/cn/hello


注意：如果是 yml 需要在 “:” 后加一个空格，幸好 IDEA 很好地支持了 yml 文件的格式有良好的代码提示；我们可以自己配置多个属性

（3）使用 yml 文件作为配置文件，我们直接把 .properties 后缀的文件删掉，使用 .yml 文件来进行简单的配置

（4）在然后使用在我们的 HelloController.java 类中使用 @Value 来获取配置属性，代码（请看注释）：
123456789101112131415161718192021222324252627282930package com.xpwi.springboot;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;** * 测试控制器 * * @author: @肖朋伟CSDN * @create: 2018-11-18 *&#x2F;@RestControllerpublic class HelloController &#123;    &#x2F;&#x2F; 获取.yml 文件中值    @Value(&quot;$&#123;name&#125;&quot;)    private String name;    &#x2F;&#x2F; 获取 age    @Value(&quot;$&#123;csdnUrl&#125;&quot;)    private String csdnUrl;    &#x2F;&#x2F;路径映射，对应浏览器访问的地址，访问该路径则执行下面函数    @RequestMapping(&quot;&#x2F;hello&quot;)    public String hello() &#123;        return name + &quot; CSDN 博客：&quot;+ csdnUrl;    &#125;&#125;1234567891011121314151617181920212223242526272829

（5）重启 Spring Boot ，输入地址：http://localhost:8080/hello 能看到正确的结果：

【注意】：此时如果你第一次使用 idea 出现中文乱码，解决办法：

（6）【注意】： 我们并没有在 yml 文件中注明属性的类型，而是在使用的时候定义的。你也可以在配置文件中使用当前配置：

（7）任然可以得到正确结果：

（8）【问题】： 这样写配置文件繁琐而且可能会造成类的臃肿，因为有许许多多的 @Value 注解。
可以，封装配置信息
封装配置信息使用方法：（1）application.yml 文件内容如下：
（2）新建 author.java 和 HelloController.java 同级，内容如下：
123456789101112131415161718192021222324252627282930package com.xpwi.springboot;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@ConfigurationProperties(prefix &#x3D; &quot;author&quot;)public class author &#123;    private  String name;    private  String csdnUrl;    public String getCsdnUrl() &#123;        return csdnUrl;    &#125;    public void setCsdnUrl(String csdnUrl) &#123;        this.csdnUrl &#x3D; csdnUrl;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;1234567891011121314151617181920212223242526272829

（3）此时可能会报错，如果报错，打开 pom.xml 文件，添加内容（注意位置）：
123456&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;            &lt;optional&gt;true&lt;&#x2F;optional&gt;        &lt;&#x2F;dependency&gt;12345


（4）重新编写 HelloController 类，内容如下：
123456789101112131415161718192021222324252627282930313233343536package com.xpwi.springboot;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;&#x2F;** * 测试控制器 * * @author: @肖朋伟CSDN * @create: 2018-11-18 *&#x2F;@RestControllerpublic class HelloController &#123;    &#x2F;&#x2F; 获取.yml 文件中值    &#x2F;&#x2F;@Value(&quot;$&#123;name&#125;&quot;)    &#x2F;&#x2F;private String name;    &#x2F;&#x2F; 获取 age    &#x2F;&#x2F;@Value(&quot;$&#123;csdnUrl&#125;&quot;)    &#x2F;&#x2F;private String csdnUrl;    @Autowired    private author author;    &#x2F;&#x2F;路径映射，对应浏览器访问的地址，访问该路径则执行下面函数    @RequestMapping(&quot;&#x2F;hello&quot;)    public String hello() &#123;        return &quot;名字：&quot; + author.getName() + &quot; 地址：&quot; + author.getCsdnUrl();    &#125;&#125;1234567891011121314151617181920212223242526272829303132333435

（5）重启 Spring Boot，访问浏览器：
12http:&#x2F;&#x2F;localhost:8080&#x2F;hello1


【提示】：我们可以把配置信息封装成一个类，首先在我们的 name 和 age 前加一个 student 前缀，然后新建一个 StudentProperties 的类用来封装这些信息，并用上两个注解：

@Component：表明当前类是一个 Java Bean
@ConfigurationProperties(prefix = “author”)：表示获取前缀为 author 的配置信息

转载请注明出处：肖朋伟：https://blog.csdn.net/qq_40147863/article/details/84194493
更多文章链接：
Spring Boot 学习笔记


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/16/2013-11-16-java-markdown-lib/">Java中使用Markdown</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-16</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/16/2013-11-16-java-markdown-lib/">
                    <p>
                        
                            由于需要将输入的markdown内容转换成html，所以找到了这个包：MarkdownPapers
Maven依赖：
12345&lt;dependency&gt;    &lt;groupId&gt;org.tautua.markdownpapers&lt;/groupId&gt;    &lt;artifactId&gt;markdownpapers-core&lt;/artifactId&gt;    &lt;version&gt;$&#123;use latest&#125;&lt;/version&gt;&lt;/dependency&gt;

使用起来非常简单：
示例12345Reader in = new FileReader(&quot;in.md&quot;);Writer out = new FileWriter(&quot;out.html&quot;);Markdown md = new Markdown();md.transform(in, out);
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/markdown/" rel="tag">markdown</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/11/12/2013-11-12-design-patterns-observer/">设计模式学习笔记观察者模式</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-11-12</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/11/12/2013-11-12-design-patterns-observer/">
                    <p>
                        
                            1. 模式定义观察者模式（Observer Pattern）也叫做发布订阅模式（Publish/subscribe），它使一个在项目中经常使用的模式。
2. 模式各角色Subject被观察者：定义被观察者必须实现的职责，它必须能够动态地增加、取消观察者。它一般是抽象类或者是实现类，仅仅完成作为被观察者必须实现的职责：管理观察者并通知观察者。
Observer观察者：观察者接收到消息后，即进行update（更新方法）操作，对接收到的信息进行处理。
ConcreteSubject具体的被观察者：定义被观察者自己的业务逻辑，同时定义对哪些事件进行通知。
ConcreteObserver具体的观察者：每个观察在接收到消息后的处理反应是不同，各个观察者有自己的处理逻辑。
3. 模式类图
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/observer/" rel="tag">observer</a>, <a class="tag-none-link" href="../../tags/%E8%A7%82%E5%AF%9F%E8%80%85/" rel="tag">观察者</a>, <a class="tag-none-link" href="../../tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/10/29/2013-10-29-tomcat-remote-debug/">Tomcat打开远程调试</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-29</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/10/29/2013-10-29-tomcat-remote-debug/">
                    <p>
                        
                            配置1.    Linux下在bin/startup.sh 或者 bin/catalina.sh 开头添加
1declare -x CATALINA_OPTS=&quot;-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8787&quot;

2.    Windows下在bin/startup.bat 或者 bin/catalina.bat 开头添加
1SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8787

调试这样启动以后，就会监听8787端口，通过IDE进行调试，这里以Eclipse示例
依次打开Run –&gt; Debug Configurations –&gt; Remote Java Application –&gt; 右键New –&gt; 填写tomcat相关信息，端口就是8787
这样启动tomcat后，再进行Debug后就可以了。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/debug/" rel="tag">debug</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>, <a class="tag-none-link" href="../../tags/remote/" rel="tag">remote</a>, <a class="tag-none-link" href="../../tags/tomcat/" rel="tag">tomcat</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/10/29/2013-05-16-tomcat-install-cert/">Tomcat安装CA证书（详细过程篇）</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-29</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/10/29/2013-05-16-tomcat-install-cert/">
                    <p>
                        
                            1.创建一个本地证书：&nbsp;C:\j2sdk1.4.2_05\bin&gt;;keytool&nbsp;-genkey&nbsp;-alias&nbsp;tomcat&nbsp;-keyalg&nbsp;RSA&nbsp;-keystore&nbsp;keystore&nbsp;输入keystore密码：&nbsp;&nbsp;12345678&nbsp;您的名字与姓氏是什么？&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;www.test.com&nbsp;您的组织单位名称是什么？&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;system&nbsp;您的组织名称是什么？&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;test&nbsp;您所在的城市或区域名称是什么？&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;beijing&nbsp;您所在的州或省份名称是什么？&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;beijing&nbsp;该单位的两字母国家代码是什么&nbsp;&nbsp;&nbsp;[Unknown]：&nbsp;&nbsp;cn&nbsp;CN=liujx,&nbsp;OU=system,&nbsp;O=test,&nbsp;L=beijing,&nbsp;ST=beijing,&nbsp;C=cn&nbsp;正确吗？&nbsp;&nbsp;&nbsp;[否]：&nbsp;&nbsp;y&nbsp;输入&lt;tomcat&gt;;的主密码&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（如果和&nbsp;keystore&nbsp;密码相同，按回车）：&nbsp;

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/IT/" rel="tag">IT</a>, <a class="tag-none-link" href="../../tags/JAVA/" rel="tag">JAVA</a>, <a class="tag-none-link" href="../../tags/TOMCAT/" rel="tag">TOMCAT</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/10/28/2014-10-28-groovy-starting/">Groovy开始</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-28</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/10/28/2014-10-28-groovy-starting/">
                    <p>
                        
                            之前看了《Java程序员修炼之道》，第三部分JVM上的多语言编程里面讲到JVM上面的一些脚本语言，有Groovy，Scala，Clojure，没有等。于是这两天学了一下Groovy，发现还真是方便，最明显的就是他的闭包Closure。
平时在用Java编程的时候，写着写着总是有点烦，一个很简单的方法都要写一堆代码，其实具体逻辑就一行，想着用闭包多好，那么Groovy完全就可以用得上。
                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/Groovy/" rel="tag">Groovy</a>, <a class="tag-none-link" href="../../tags/IT/" rel="tag">IT</a>, <a class="tag-none-link" href="../../tags/JVM/" rel="tag">JVM</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/10/23/2013-05-16-hibernate-load-get-compare/">Hibernate的load和get比较</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-10-23</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/10/23/2013-05-16-hibernate-load-get-compare/">
                    <p>
                        
                            get和load的实现

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;load event(产生) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;onLoad Event
&nbsp; &nbsp; &nbsp;&nbsp;Hibernate&nbsp;--------------------&gt;LoadEventListener---------------&gt;event①------&gt;return event-----&gt;getResult()
&nbsp; &nbsp;&nbsp;其中：①:------&gt;setResult(event.session(查找))

未使用二级缓存 &nbsp; &nbsp;&nbsp;
load 先从缓存（一级）中查找，如果没有查询结果，就到数据库中查找，不管查询结果如何，都返回XX_$$_javassist_0对象（代理类实例）。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/IT/" rel="tag">IT</a>, <a class="tag-none-link" href="../../tags/JAVA/" rel="tag">JAVA</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/08/28/2017-08-28-i18next/">i18next</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-28</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/08/28/2017-08-28-i18next/">
                    <p>
                        
                            I18next 是一款用JavaScript编写的国际化框架。
为什么需要国际化一般在编写网站的时候，网页需要向用户展现一些文字，假如你的网站完全面向中国用户，那么你可以把网页里的内容写成中文。但是如果你还要面向英文用户，那么你就不能直接把内容写成中文了，你的网站需要国际化。你需要使用一些技术来让程序自动切换内容的显示，网页的总体结构是不变的，但是内容需要随着用户的改变而改变。
但是可能有人会说，各准备一个英文和一个中文的网页不就可以了吗？那么请问以后再出现法文，葡萄牙文，西班牙文的需求呢？这种需求其实很常见，比如ebay.com，它面向不同国家有不同的显示，甚至在一个国家还有多种显示（比如加拿大，分为加拿大英语区和加拿大法语区）。如果针对一种语言准备一套网站，那将是大大的代码冗余和资源的浪费。
为什么使用i18nextI18next提供了JavaScript开发中能想到的所有关于i18n的需求，它提供了一个完整的解决方案，不管是本地客户端还是服务端，移动端Web还是桌面端Web。当然，它不仅仅可以用在JavaScript平台，它还能用在其他平台，比如php，ios等。
以下是官方的一段话：

Learn once - use everywhere. The community made integrations for frameworks like react.js, angular.js, vue.js and many more. But this is not where it ends…you can use i18next with node.js, php, ios, android and other platforms.


I18next reached not only the web, but also mobile and desktop development.

翻译过来大概意思是：它的社区已经将i18next和react.js，angular.js，vue.js等热门的框架集成，而且你能在Node.js，php，ios，android等平台上使用，除了Web端，你还能在手机端桌面端的开发中使用。
开始使用安装12345678# yarn$ yarn add i18next# npm$ npm install i18next --save# bower$ bower install i18next

Hello World这里直接修改自官网的Hello World：
123456789101112131415161718var i18next = require(&#x27;i18next&#x27;);var option = &#123;  lng: &#x27;en&#x27;,  resources: &#123;    en: &#123;      translation: &#123;        &quot;hello-world&quot;: &quot;Hello world!&quot;      &#125;    &#125;  &#125;&#125;;var callback = function(err, t) &#123;  console.log(i18next.t(&#x27;hello-world&#x27;));&#125;i18next.init(option, callback);

执行过后会输出：
123$ node .Hello world!Done in 0.18s.

这里调用的是 i18next 的 init() api 进行初始化，init()需要传入两个参数option和callback函数。
在 callback 函数中, i18next.t(‘hello-world’) 就是键 ‘hello-world’ 所对应值 ‘Hello world!’。
在 option 中，lng 表示当前采用的是 en 语言所对应的资源，而 resources 就是资源配置。那么，如果想输出中文呢？很简单，只要在 resources 中加入对应语言的键值对即可：
1234567891011121314151617181920212223var i18next = require(&#x27;i18next&#x27;);var option = &#123;  lng: &#x27;zh_CN&#x27;,  resources: &#123;    en: &#123;      translation: &#123;        &quot;hello-world&quot;: &quot;Hello world!&quot;      &#125;    &#125;,    zh_CN: &#123;      translation: &#123;        &quot;hello-world&quot;: &quot;你好世界！&quot;      &#125;    &#125;  &#125;&#125;;var callback = function(err, t) &#123;  console.log(i18next.t(&#x27;hello-world&#x27;));&#125;i18next.init(option, callback);

再将 option.lng 改为 ‘zh_CN’，这样执行后输出：
123$ node .你好世界！Done in 0.18s.

最基本的国际化方案就是这么简单，实际应用中会根据用户的某些国家属性来决定使用哪套资源，举个例子，用eBay来说，假如用户直接访问 www.ebay.com，系统会默认显示英文，假如用户访问www.ebay.ch，看上去整个网页的结构布局和 www.ebay.com 一样，只不过语言变成了德文，这里就是根据域名的不同来选择不同的服务器，而不同的服务器实际上运行的是一套代码。
当然还可以根据用户所在国家自动显示不同的语言，在这里就不多说了。
以上代码完整的项目地址是 https://github.com/henryhuang/i18next-samples/tree/master/i18next-basic-sample .
结合 Express 使用主要的代码如下：
1234567891011121314151617181920212223...// 初始化 i18nexti18n.use(i18nMiddleware.LanguageDetector).use(i18nFsBackend).init(&#123;  lng: &#x27;en&#x27;,  preload: [    &#x27;en&#x27;, &#x27;zh-CN&#x27;  ],  backend: &#123;    loadPath: path.resolve(__dirname, &#x27;./lang/&#123;&#123;lng&#125;&#125;/translation.json&#x27;)  &#125;&#125;);//app.use(i18nMiddleware.handle(i18n));...app.get(&#x27;/lang/:lang&#x27;, function(req, res) &#123;  res.cookie(&#x27;i18next&#x27;, req.params.lang);  res.redirect(&#x27;/&#x27;);&#125;);

完整的项目代码在这里 https://github.com/henryhuang/i18next-samples/tree/master/i18next-express-sample .

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/JavaScript/" rel="tag">JavaScript</a>, <a class="tag-none-link" href="../../tags/Node-js/" rel="tag">Node.js</a>, <a class="tag-none-link" href="../../tags/express/" rel="tag">express</a>, <a class="tag-none-link" href="../../tags/i18n/" rel="tag">i18n</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="../../2020/08/01/2013-08-01-java-date-am-or-pm/">JAVA中判断日期是上午还是下午</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2020-08-01</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="../../2020/08/01/2013-08-01-java-date-am-or-pm/">
                    <p>
                        
                            12GregorianCalendar cal = new GregorianCalendar();System.out.println((cal.get(GregorianCalendar.AM_PM) == GregorianCalendar.PM)? &quot;下午&quot; : &quot;上午&quot;);

当然，通过GregorianCalendar.get()还可以获取更多的信息。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                        <i class="fa fa-folder-open-o"></i>
                        <a class="category-link" href="">java</a>

                        
                            <span class="dotted">|</span>
                        

                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="../../tags/date/" rel="tag">date</a>, <a class="tag-none-link" href="../../tags/it/" rel="tag">it</a>, <a class="tag-none-link" href="../../tags/java/" rel="tag">java</a>
                    
                </div>
            
        </article>
    



    <nav class="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="page/2/">2</a><a class="extend next" rel="next" href="page/2/">Next</a>
    </nav>

            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            博落回
        </p>
        <p class="slogan">流连矣 忘景幻云催 峦栈醺醺说旧梦 重山迟迟映霞辉 向晚共邀归 —— 忆江南</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">Recent</div>
    <ul class="item-box">
        
            
                <li><a href="../../2021/05/04/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E7%9A%84%E6%83%8A%E5%96%9C/">小红书的惊喜</a></li>
            
        
            
                <li><a href="../../2021/05/03/%E2%80%9C%E5%8D%97%E4%BA%AC%E5%8F%8B%E8%AE%B0-%E6%9D%8E%E5%AE%B6%E9%A6%A8%E2%80%9D/">南京友记-李家馨</a></li>
            
        
            
                <li><a href="../../2021/05/01/%E5%8D%97%E4%BA%AC%E4%B9%8B%E6%97%85-episode-1/">南京之旅-中山陵</a></li>
            
        
            
                <li><a href="../../2021/04/24/%E2%80%9C%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E2%80%9D/">“计算机文件系统”</a></li>
            
        
            
                <li><a href="../../2021/04/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%BA%8C%E7%AB%A0%E6%80%BB%E7%BB%93/">线性代数第二章总结</a></li>
            
        
            
                <li><a href="../../2021/04/23/2020%E8%80%83%E7%A0%94%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%88408%EF%BC%89%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">2020考研计算机（408）考试大纲</a></li>
            
        
            
                <li><a href="../../2021/04/22/%E2%80%9C%E5%B9%82%E7%BA%A7%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8%E2%80%9D/">“幂级数的本质”</a></li>
            
        
            
                <li><a href="../../2021/04/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%8A%82%E6%80%BB%E7%BB%93/">线性代数第一章节总结</a></li>
            
        
    </ul>
</div>

    
        
    <div class="box widget">
        <div class="title">Categories</div>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="../hexo/">hexo</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="">java</a><span class="category-list-count">36</span></li><li class="category-list-item"><a class="category-list-link" href="../mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../ui/">ui</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="../%E4%B8%89%E5%89%91%E5%AE%A2/">三剑客</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="../%E7%94%9F%E6%B4%BB/">生活</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="../%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86/">计算机常识</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="../%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88/">计算机网络综合</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="../%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/">高等数学</a><span class="category-list-count">7</span></li></ul>
    </div>

    
        
  <div class="box widget">
    <div class="title">Archives</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/05/">2021-05</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/04/">2021-04</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/03/">2021-03</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/02/">2021-02</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2021/01/">2021-01</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/12/">2020-12</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/11/">2020-11</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/10/">2020-10</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/09/">2020-09</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/08/">2020-08</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/07/">2020-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/06/">2020-06</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/03/">2020-03</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2020/02/">2020-02</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/12/">2019-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/10/">2019-10</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/08/">2019-08</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/07/">2019-07</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/06/">2019-06</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/05/">2019-05</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/03/">2019-03</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2019/02/">2019-02</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/12/">2018-12</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/11/">2018-11</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/05/">2018-05</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/04/">2018-04</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2018/03/">2018-03</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2016/04/">2016-04</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2015/04/">2015-04</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="../../archives/2013/06/">2013-06</a><span class="archive-list-count">1</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">Tags</div>
        <div class="item-box cloud-label">
            <a href="../../tags/CSS/" style="font-size: 11.11px;">CSS</a> <a href="../../tags/Eclipse/" style="font-size: 10px;">Eclipse</a> <a href="../../tags/Field/" style="font-size: 10px;">Field</a> <a href="../../tags/Groovy/" style="font-size: 10px;">Groovy</a> <a href="../../tags/HTML/" style="font-size: 11.11px;">HTML</a> <a href="../../tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="../../tags/IDE/" style="font-size: 11.11px;">IDE</a> <a href="../../tags/IT/" style="font-size: 17.78px;">IT</a> <a href="../../tags/JAVA/" style="font-size: 12.22px;">JAVA</a> <a href="../../tags/JVM/" style="font-size: 10px;">JVM</a> <a href="../../tags/Java/" style="font-size: 14.44px;">Java</a> <a href="../../tags/JavaScript/" style="font-size: 11.11px;">JavaScript</a> <a href="../../tags/MYSQL/" style="font-size: 10px;">MYSQL</a> <a href="../../tags/Maven/" style="font-size: 10px;">Maven</a> <a href="../../tags/NoSql/" style="font-size: 10px;">NoSql</a> <a href="../../tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="../../tags/Python/" style="font-size: 10px;">Python</a> <a href="../../tags/TOMCAT/" style="font-size: 10px;">TOMCAT</a> <a href="../../tags/UI/" style="font-size: 10px;">UI</a> <a href="../../tags/VMware/" style="font-size: 10px;">VMware</a> <a href="../../tags/Wicket/" style="font-size: 10px;">Wicket</a> <a href="../../tags/coding/" style="font-size: 10px;">coding</a> <a href="../../tags/coding-net/" style="font-size: 12.22px;">coding.net</a> <a href="../../tags/css/" style="font-size: 13.33px;">css</a> <a href="../../tags/date/" style="font-size: 10px;">date</a> <a href="../../tags/debug/" style="font-size: 10px;">debug</a> <a href="../../tags/decorator/" style="font-size: 10px;">decorator</a> <a href="../../tags/eclipse/" style="font-size: 10px;">eclipse</a> <a href="../../tags/editor/" style="font-size: 10px;">editor</a> <a href="../../tags/equals/" style="font-size: 10px;">equals</a> <a href="../../tags/express/" style="font-size: 10px;">express</a> <a href="../../tags/git/" style="font-size: 10px;">git</a> <a href="../../tags/github/" style="font-size: 12.22px;">github</a> <a href="../../tags/gogs/" style="font-size: 10px;">gogs</a> <a href="../../tags/hexo/" style="font-size: 16.67px;">hexo</a> <a href="../../tags/https/" style="font-size: 10px;">https</a> <a href="../../tags/i18n/" style="font-size: 10px;">i18n</a> <a href="../../tags/ini/" style="font-size: 10px;">ini</a> <a href="../../tags/it/" style="font-size: 15.56px;">it</a> <a href="../../tags/jar/" style="font-size: 10px;">jar</a> <a href="../../tags/java/" style="font-size: 20px;">java</a> <a href="../../tags/javascript/" style="font-size: 12.22px;">javascript</a> <a href="../../tags/jdk/" style="font-size: 10px;">jdk</a> <a href="../../tags/jvm/" style="font-size: 10px;">jvm</a> <a href="../../tags/less/" style="font-size: 10px;">less</a> <a href="../../tags/linux/" style="font-size: 11.11px;">linux</a> <a href="../../tags/mac/" style="font-size: 12.22px;">mac</a> <a href="../../tags/macvim/" style="font-size: 10px;">macvim</a> <a href="../../tags/markdown/" style="font-size: 10px;">markdown</a> <a href="../../tags/maven/" style="font-size: 11.11px;">maven</a> <a href="../../tags/mediator/" style="font-size: 10px;">mediator</a> <a href="../../tags/nginx/" style="font-size: 10px;">nginx</a> <a href="../../tags/object/" style="font-size: 10px;">object</a> <a href="../../tags/observer/" style="font-size: 10px;">observer</a> <a href="../../tags/qcloud/" style="font-size: 10px;">qcloud</a> <a href="../../tags/rails/" style="font-size: 10px;">rails</a> <a href="../../tags/reflect/" style="font-size: 10px;">reflect</a> <a href="../../tags/remote/" style="font-size: 10px;">remote</a> <a href="../../tags/ssh/" style="font-size: 10px;">ssh</a> <a href="../../tags/ssl/" style="font-size: 10px;">ssl</a> <a href="../../tags/tomcat/" style="font-size: 10px;">tomcat</a> <a href="../../tags/travis/" style="font-size: 12.22px;">travis</a> <a href="../../tags/vim/" style="font-size: 11.11px;">vim</a> <a href="../../tags/web/" style="font-size: 11.11px;">web</a> <a href="../../tags/webjars/" style="font-size: 11.11px;">webjars</a> <a href="../../tags/wicket/" style="font-size: 11.11px;">wicket</a> <a href="../../tags/%E4%B8%AD%E4%BB%8B%E8%80%85/" style="font-size: 10px;">中介者</a> <a href="../../tags/%E5%81%87%E6%9C%9F/" style="font-size: 10px;">假期</a> <a href="../../tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 10px;">分布式</a> <a href="../../tags/%E5%89%8D%E7%AB%AF/" style="font-size: 11.11px;">前端</a> <a href="../../tags/%E5%91%A8%E6%9C%AB/" style="font-size: 11.11px;">周末</a> <a href="../../tags/%E5%9B%BE%E7%89%87/" style="font-size: 11.11px;">图片</a> <a href="../../tags/%E5%A5%BD%E6%96%87/" style="font-size: 10px;">好文</a> <a href="../../tags/%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 10px;">小知识点</a> <a href="../../tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 10px;">工作</a> <a href="../../tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="../../tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a> <a href="../../tags/%E5%BF%83%E6%83%85/" style="font-size: 10px;">心情</a> <a href="../../tags/%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">技术</a> <a href="../../tags/%E6%95%99%E7%A8%8B/" style="font-size: 10px;">教程</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84/" style="font-size: 10px;">数据机构</a> <a href="../../tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="../../tags/%E6%96%87%E7%AB%A0/" style="font-size: 10px;">文章</a> <a href="../../tags/%E6%97%A0%E5%9B%BE/" style="font-size: 10px;">无图</a> <a href="../../tags/%E6%97%A5%E5%BF%97/" style="font-size: 18.89px;">日志</a> <a href="../../tags/%E6%97%A5%E8%AE%B0/" style="font-size: 10px;">日记</a> <a href="../../tags/%E6%9D%82%E4%BA%8B/" style="font-size: 16.67px;">杂事</a> <a href="../../tags/%E6%9D%82%E6%96%87/" style="font-size: 10px;">杂文</a> <a href="../../tags/%E6%9D%82%E8%B0%88/" style="font-size: 10px;">杂谈</a> <a href="../../tags/%E6%B2%B9%E6%BC%86%E5%B7%A5/" style="font-size: 10px;">油漆工</a> <a href="../../tags/%E7%94%9F%E6%B4%BB/" style="font-size: 11.11px;">生活</a> <a href="../../tags/%E7%94%B5%E5%BD%B1/" style="font-size: 10px;">电影</a> <a href="../../tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" style="font-size: 10px;">线性代数</a> <a href="../../tags/%E7%BD%91%E7%BB%9C/" style="font-size: 10px;">网络</a> <a href="../../tags/%E8%88%B6%E6%9D%A5%E5%93%81/" style="font-size: 10px;">舶来品</a> <a href="../../tags/%E8%89%BA%E6%9C%AF%E5%AE%B6/" style="font-size: 10px;">艺术家</a> <a href="../../tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">虚拟机</a> <a href="../../tags/%E8%A7%82%E5%AF%9F%E8%80%85/" style="font-size: 10px;">观察者</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" style="font-size: 14.44px;">计算机</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%AF%86/" style="font-size: 10px;">计算机常识</a> <a href="../../tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 14.44px;">计算机网络</a> <a href="../../tags/%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">记录</a> <a href="../../tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 14.44px;">设计模式</a> <a href="../../tags/%E8%AF%B4%E7%82%B9%E5%95%A5/" style="font-size: 10px;">说点啥</a> <a href="../../tags/%E8%BF%90%E5%8A%A8/" style="font-size: 10px;">运动</a> <a href="../../tags/%E9%A3%8E%E6%99%AF/" style="font-size: 10px;">风景</a> <a href="../../tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 14.44px;">高等数学</a>
        </div>
    </div>

    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
            <span class="dotted">|</span>
            <span><a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn">浙ICP备18016660号-1</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>